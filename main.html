<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>KO II Audio Tool</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
      background-color: black;
      color: #33ff33;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: start;
      height: 100vh;
      padding-top: 20px;
      box-sizing: border-box;
    }
    #drop-zone {
      border: 2px dashed #33ff33;
      padding: 30px;
      text-align: center;
      width: 90%;
      max-width: 500px;
      cursor: pointer;
    }
    #drop-zone.dragover {
      background-color: #111;
    }
    #overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #33ff33;
    }
    #win95-loader {
      display: none;
      font-size: 18px;
      margin-bottom: 10px;
    }
    .progress-bar {
      display: flex;
      gap: 1px;
    }
    .progress-segment {
      width: 6px;
      height: 20px;
      background: #222;
      border: 1px solid #33ff33;
    }
    .progress-segment.active {
      background: #33ff33;
    }
    #file-info {
      margin-top: 20px;
      font-size: 12px;
      white-space: pre-wrap;
    }
    audio {
      margin-top: 15px;
    }
    .options {
      margin-top: 10px;
      text-align: left;
    }
    .options label {
      display: block;
      margin: 3px 0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>

  <div class="options">
    <div>
      Fidelity:
      <label><input type="radio" name="fidelity" value="sp8" checked /> SP-8</label>
      <label><input type="radio" name="fidelity" value="sp16" /> SP-16</label>
      <label><input type="radio" name="fidelity" value="sk" /> SK</label>
    </div>
    <div>
      Channels:
      <label><input type="radio" name="channels" value="mono" checked /> Mono</label>
      <label><input type="radio" name="channels" value="stereo" /> Stereo</label>
    </div>
  </div>

  <div id="drop-zone">Drop audio files here or click to select</div>
  <input type="file" id="audio-upload" accept="audio/*" multiple style="display: none;" />

  <audio id="player" controls style="display: none;"></audio>

  <div id="file-info"></div>

  <div id="overlay">
    <div id="win95-loader">Processing files...</div>
    <div class="progress-bar" id="segment-container"></div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('audio-upload');
    const player = document.getElementById('player');
    const overlay = document.getElementById('overlay');
    const loader = document.getElementById('win95-loader');
    const segmentContainer = document.getElementById('segment-container');
    const fileInfo = document.getElementById('file-info');

    const getSelectedValue = (name) => document.querySelector(`input[name="${name}"]:checked`)?.value;
    const initAudioContext = () => new (window.AudioContext || window.webkitAudioContext)();

    const getDownsampleRate = (fidelity, originalRate) => {
      switch (fidelity) {
        case 'sp8': return 10000;
        case 'sp16': return 16000;
        case 'sk': return 9000;
        default: return originalRate;
      }
    };

    const convertChannels = async (buffer, channels) => {
      const ctx = new OfflineAudioContext(channels === 'mono' ? 1 : 2, buffer.length, buffer.sampleRate);
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      if (channels === 'mono') {
        const merger = ctx.createChannelMerger(1);
        const splitter = ctx.createChannelSplitter(buffer.numberOfChannels);
        source.connect(splitter);
        for (let i = 0; i < buffer.numberOfChannels; i++) splitter.connect(merger, i, 0);
        merger.connect(ctx.destination);
      } else {
        source.connect(ctx.destination);
      }
      source.start();
      return await ctx.startRendering();
    };

    const applySpeedAndFidelity = async (buffer, speed, sampleRate) => {
      const length = Math.floor(buffer.length / speed);
      const ctx = new OfflineAudioContext(buffer.numberOfChannels, length, sampleRate);
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.playbackRate.value = speed;
      source.connect(ctx.destination);
      source.start();
      return await ctx.startRendering();
    };

    const audioBufferToWav = (buffer) => {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const length = buffer.length;
      const bufferArray = new ArrayBuffer(44 + length * 2 * numChannels);
      const view = new DataView(bufferArray);
      const writeString = (offset, str) => [...str].forEach((c, i) => view.setUint8(offset + i, c.charCodeAt(0)));
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + length * 2 * numChannels, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numChannels * 2, true);
      view.setUint16(32, numChannels * 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length * 2 * numChannels, true);
      let offset = 44;
      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i])) * 32767;
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    };

    async function animateSegments(start, end) {
      const segments = document.querySelectorAll('.progress-segment');
      for (let i = start; i <= end; i++) {
        if (segments[i]) {
          segments[i].classList.add('active');
          await new Promise(res => setTimeout(res, 60));
        }
      }
    }

    async function processFiles(files) {
      overlay.style.display = 'flex';
      loader.style.display = 'block';
      const context = initAudioContext();
      const totalSegments = 50;
      const segmentsPerFile = files.length === 1 ? totalSegments : Math.floor(totalSegments / files.length);
      segmentContainer.innerHTML = '';
      fileInfo.innerHTML = '';
      const zip = new JSZip();

      for (let i = 0; i < totalSegments; i++) {
        const seg = document.createElement('div');
        seg.className = 'progress-segment';
        segmentContainer.appendChild(seg);
      }

      for (let i = 0; i < files.length; i++) {
        const startSeg = i * segmentsPerFile;
        const endSeg = Math.min(startSeg + segmentsPerFile - 1, totalSegments - 1);
        animateSegments(startSeg, endSeg);
        const file = files[i];
        const arrayBuffer = await file.arrayBuffer();
        const decoded = await context.decodeAudioData(arrayBuffer);
        const fidelity = getSelectedValue('fidelity');
        const channels = getSelectedValue('channels');
        const converted = await convertChannels(decoded, channels);
        const downsampleRate = getDownsampleRate(fidelity, converted.sampleRate);
        const processed = await applySpeedAndFidelity(converted, 2.0, downsampleRate);
        const wavBlob = audioBufferToWav(processed);
        const fileName = file.name.replace(/\.[^/.]+$/, '') + '_processed.wav';
        zip.file(fileName, wavBlob);

        if (i === 0) {
          player.src = URL.createObjectURL(wavBlob);
          player.style.display = 'block';
          player.load();
          const originalSize = (file.size / 1024 / 1024).toFixed(2);
          const processedSize = (wavBlob.size / 1024 / 1024).toFixed(2);
          fileInfo.innerHTML = `
<b>${file.name}</b>
Original: ${originalSize} MB
Processed: ${processedSize} MB
Fidelity: ${fidelity}
Channels: ${channels}`;
        }
      }

      const zipBlob = await zip.generateAsync({ type: 'blob' });
      saveAs(zipBlob, 'KOII_Audio_Processed.zip');
      document.querySelectorAll('.progress-segment').forEach(seg => seg.classList.add('active'));
      setTimeout(() => {
        overlay.style.display = 'none';
        loader.style.display = 'none';
      }, 500);
    }

    dropZone.addEventListener('dragover', e => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', e => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) processFiles(e.dataTransfer.files);
    });

    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      if (fileInput.files.length > 0) processFiles(fileInput.files);
    });
  });
  </script>
</body>
</html>