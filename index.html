<!DOCTYPE html>
<html lang="ru">
<head>
  <!-- ... (остальная часть head без изменений) ... -->
</head>
<body>
  <!-- ... (остальная часть body без изменений) ... -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Глобальные переменные
    let activeAudioContext = null;
    let createdObjectURLs = [];
    let dragCounter = 0;
    let processingCancelled = false;
    let currentProcessing = null;
    let lastProgress = 0;
    let windowZIndex = 100;
    let audioContextInitialized = false;
    let memoryWarningShown = false;
    let processedFiles = [];
    let vocalSeparatedStems = {};
    let vocalSelectedFile = null;
    let pos3 = 0, pos4 = 0;
    let currentPreviewUrl = null;

    // Инициализация приложения
    document.addEventListener('DOMContentLoaded', () => {
      initApp();
    });

    function openWindow(type) {
      if (type === 'main') {
        document.getElementById('main-window').style.display = 'block';
        document.getElementById('main-window').style.zIndex = windowZIndex++;
      } else if (type === 'vocal') {
        document.getElementById('vocal-window').style.display = 'block';
        document.getElementById('vocal-window').style.zIndex = windowZIndex++;
      }
    }

    function initApp() {
      // Назначение обработчиков для иконок
      document.querySelectorAll('.desktop-icon').forEach((icon, index) => {
        icon.onclick = function() {
          if (index === 0) {
            openWindow('main');
          } else {
            openWindow('vocal');
          }
        };
      });

      // Проверка мобильного устройства
      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        document.getElementById('mobile-warning').style.display = 'block';
      }
      
      // Проверка памяти
      checkMemoryAndWarn();
      
      // Назначение обработчиков событий
      document.querySelectorAll('.win95-list').forEach(group => {
        group.addEventListener('click', e => {
          if (e.target.classList.contains('list-item')) {
            group.querySelectorAll('.list-item').forEach(item => {
              item.classList.remove('selected');
            });
            e.target.classList.add('selected');
            updateStatus(`Fidelity set to: ${e.target.textContent}`);
          }
        });
      });

      // Элементы интерфейса
      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('audio-upload');
      const folderInput = document.getElementById('folder-upload');
      const selectFileButton = document.getElementById('select-file-button');
      const selectFolderButton = document.getElementById('select-folder-button');
      const clearButton = document.getElementById('clear-button');
      const cancelButton = document.getElementById('cancel-button');
      const playButton = document.getElementById('play-button');
      const stopButton = document.getElementById('stop-button');
      const previewAudio = document.getElementById('preview-audio');

      // Drag and drop
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleDrop);
      
      // Поддержка touch для мобильных устройств
      dropZone.addEventListener('touchmove', e => {
        e.preventDefault();
        dragCounter++;
        dropZone.classList.add('dragover');
      }, {passive: false});
      
      dropZone.addEventListener('touchend', handleDragLeave);
      
      // Кнопки выбора
      selectFileButton.addEventListener('click', () => fileInput.click());
      selectFolderButton.addEventListener('click', () => folderInput.click());
      
      clearButton.addEventListener('click', () => {
        document.getElementById('file-info').innerHTML = 
          '<div>Drop or select audio files/folders to process</div>' +
          '<div>Files will be sped up 2x to save space</div>' +
          '<div>Auto-trim removes silence at start and end</div>' +
          '<div>Folder structure will be preserved in output</div>' +
          '<div>Note: Original MP3/OGG files may increase in size when converted to WAV</div>';
        document.getElementById('preview-container').style.display = 'none';
        updateStatus("File list cleared");
      });
      
      fileInput.addEventListener('change', (e) => {
        processFiles(e.target.files);
        e.target.value = null;
      });
      
      folderInput.addEventListener('change', (e) => {
        processFolder(e.target.files);
        e.target.value = null;
      });
      
      // Обработка кнопок окна
      document.querySelector('#main-window .title-bar .minimize').addEventListener('click', () => {
        document.getElementById('main-window').style.display = 'none';
      });
      
      document.querySelector('#main-window .title-bar .close').addEventListener('click', () => {
        document.getElementById('main-window').style.display = 'none';
      });
      
      // Кнопка отмены
      cancelButton.addEventListener('click', () => {
        processingCancelled = true;
        
        if (currentProcessing) {
          currentProcessing.cancel();
        }
        
        hideOverlay();
        updateStatus("Processing cancelled");
      });
      
      // Перемещение основного окна
      document.querySelector('#main-window .title-bar').addEventListener('mousedown', function(e) {
        dragMouseDown(e, document.getElementById('main-window'));
      });
      
      // Play/stop preview
      playButton.addEventListener('click', () => {
        previewAudio.play();
      });
      
      stopButton.addEventListener('click', () => {
        previewAudio.pause();
        previewAudio.currentTime = 0;
      });
      
      // Инициализация Vocal Remover
      initVocalRemover();
      
      // Стартовый статус
      updateStatus("Ready to process files");
    }
    
    function initVocalRemover() {
      const vocalDropZone = document.getElementById('vocal-drop-zone');
      const vocalUpload = document.getElementById('vocal-upload');
      const processButton = document.getElementById('process-button');
      const downloadAllButton = document.getElementById('download-all-button');
      const vocalWindow = document.getElementById('vocal-window');
      const closeButton = vocalWindow.querySelector('.title-bar .close');
      const minimizeButton = vocalWindow.querySelector('.title-bar .minimize');
      
      // Drag and drop
      vocalDropZone.addEventListener('dragover', handleVocalDragOver);
      vocalDropZone.addEventListener('dragleave', handleVocalDragLeave);
      vocalDropZone.addEventListener('drop', handleVocalDrop);
      
      // Обработчики кнопок
      vocalDropZone.addEventListener('click', () => vocalUpload.click());
      vocalUpload.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleVocalFileSelect(e.target.files[0]);
        }
      });
      
      processButton.addEventListener('click', processVocalSeparation);
      downloadAllButton.addEventListener('click', downloadAllStems);
      
      // Управление окном
      closeButton.addEventListener('click', () => {
        vocalWindow.style.display = 'none';
      });
      
      minimizeButton.addEventListener('click', () => {
        const content = vocalWindow.querySelector('.content');
        content.style.display = content.style.display === 'none' ? 'block' : 'none';
      });
      
      // Перемещение окна
      vocalWindow.querySelector('.title-bar').addEventListener('mousedown', function(e) {
        dragMouseDown(e, vocalWindow);
      });
    }
    
    function handleVocalDragOver(e) {
      e.preventDefault();
      document.getElementById('vocal-drop-zone').classList.add('dragover');
    }
    
    function handleVocalDragLeave() {
      document.getElementById('vocal-drop-zone').classList.remove('dragover');
    }
    
    function handleVocalDrop(e) {
      e.preventDefault();
      document.getElementById('vocal-drop-zone').classList.remove('dragover');
      
      if (e.dataTransfer.files.length > 0) {
        handleVocalFileSelect(e.dataTransfer.files[0]);
      }
    }
    
    function handleVocalFileSelect(file) {
      if (!isSupportedAudioType(file.type, file.name)) {
        alert(`Unsupported file type: ${file.type || file.name.split('.').pop()}`);
        return;
      }
      
      if (file.size > 100 * 1024 * 1024) {
        alert(`File size exceeds 100MB limit (${(file.size/(1024*1024)).toFixed(1)}MB)`);
        return;
      }
      
      // Показываем информацию о файле
      const dropZone = document.getElementById('vocal-drop-zone');
      dropZone.innerHTML = `
        <i class="fas fa-file-audio" style="font-size: 36px;"></i>
        <div style="margin: 10px 0; font-weight: bold;">${escapeHTML(file.name)}</div>
        <div>${(file.size/(1024*1024)).toFixed(2)} MB</div>
        <div class="supported-formats">Ready for separation</div>
      `;
      
      // Сохраняем файл для обработки
      vocalSelectedFile = file;
      document.getElementById('process-button').disabled = false;
      updateStatus(`File selected: ${file.name}`);
    }
    
    async function processVocalSeparation() {
      if (!vocalSelectedFile) {
        alert("Please select an audio file first");
        return;
      }
      
      const model = document.getElementById('model-select').value;
      const quality = document.getElementById('quality-select').value;
      
      const processButton = document.getElementById('process-button');
      
      // Показываем индикатор загрузки
      processButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
      processButton.disabled = true;
      
      // Скрываем предыдущие результаты
      document.getElementById('vocal-results').style.display = 'none';
      
      try {
        // Имитация процесса разделения
        await simulateSeparationProcess(vocalSelectedFile, model, processButton);
        
        // Показываем результаты
        showSeparationResults(model);
        updateStatus("Vocal separation completed");
        
      } catch (error) {
        console.error("Separation error:", error);
        alert(`Error during processing: ${error.message}`);
        updateStatus(`Error: ${error.message}`);
      } finally {
        processButton.innerHTML = '<i class="fas fa-cogs"></i> Separate Tracks';
        processButton.disabled = false;
      }
    }
    
    async function simulateSeparationProcess(file, model, processButton) {
      return new Promise((resolve) => {
        const stems = {};
        const stemNames = {
          '2stems': ['Vocals', 'Accompaniment'],
          '4stems': ['Vocals', 'Drums', 'Bass', 'Other'],
          '5stems': ['Vocals', 'Drums', 'Bass', 'Piano', 'Other']
        };
        
        let progress = 0;
        const progressInterval = setInterval(() => {
          progress = Math.min(100, progress + Math.random() * 10);
          
          processButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Processing... ${Math.round(progress)}%`;
          
          if (progress >= 100) {
            clearInterval(progressInterval);
            
            stemNames[model].forEach(stem => {
              stems[stem] = {
                name: `${stem}.mp3`,
                data: new Blob([`Fake audio data for ${stem}`], { type: 'audio/mpeg' }),
                waveform: generateRandomWaveform()
              };
            });
            
            vocalSeparatedStems = stems;
            resolve();
          }
        }, 300);
      });
    }
    
    function generateRandomWaveform() {
      const canvas = document.createElement('canvas');
      canvas.width = 200;
      canvas.height = 50;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#0f0';
      const centerY = canvas.height / 2;
      
      for (let x = 0; x < canvas.width; x += 2) {
        const amplitude = Math.random() * (canvas.height / 2 - 5);
        ctx.fillRect(x, centerY - amplitude, 1, amplitude * 2);
      }
      
      return canvas.toDataURL();
    }
    
    function showSeparationResults(model) {
      const stemContainer = document.getElementById('stem-container');
      stemContainer.innerHTML = '';
      
      Object.keys(vocalSeparatedStems).forEach(stemName => {
        const stem = vocalSeparatedStems[stemName];
        const stemItem = document.createElement('div');
        stemItem.className = 'stem-item';
        
        stemItem.innerHTML = `
          <div class="stem-name">${escapeHTML(stemName)}</div>
          <div class="stem-preview">
            <img src="${stem.waveform}" alt="${escapeHTML(stemName)} waveform" style="width: 100%; height: 100%;">
          </div>
          <button class="stem-button download-stem" data-stem="${escapeHTML(stemName)}">
            <i class="fas fa-download"></i> Download
          </button>
        `;
        
        stemContainer.appendChild(stemItem);
      });
      
      document.querySelectorAll('.download-stem').forEach(button => {
        button.addEventListener('click', (e) => {
          const stemName = e.target.closest('.download-stem').dataset.stem;
          downloadStem(stemName);
        });
      });
      
      document.getElementById('vocal-results').style.display = 'block';
    }
    
    function downloadStem(stemName) {
      const stem = vocalSeparatedStems[stemName];
      if (!stem) return;
      
      const url = URL.createObjectURL(stem.data);
      const a = document.createElement('a');
      a.href = url;
      a.download = stem.name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      updateStatus(`Downloaded: ${stem.name}`);
    }
    
    function downloadAllStems() {
      const zip = new JSZip();
      
      Object.keys(vocalSeparatedStems).forEach(stemName => {
        const stem = vocalSeparatedStems[stemName];
        zip.file(stem.name, stem.data);
      });
      
      zip.generateAsync({ type: 'blob' }).then(content => {
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'separated_stems.zip';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        updateStatus("Downloaded all stems as ZIP");
      });
    }
    
    // Функция для перемещения окна
    function dragMouseDown(e, windowElement) {
      e.preventDefault();
      windowZIndex += 2;
      windowElement.style.zIndex = windowZIndex;
      
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.addEventListener('mouseup', closeDragElement);
      document.addEventListener('mousemove', elementDrag);
      
      function elementDrag(e) {
        e.preventDefault();
        const newX = windowElement.offsetLeft - (pos3 - e.clientX);
        const newY = windowElement.offsetTop - (pos4 - e.clientY);
        
        windowElement.style.left = newX + "px";
        windowElement.style.top = newY + "px";
        
        pos3 = e.clientX;
        pos4 = e.clientY;
      }
      
      function closeDragElement() {
        document.removeEventListener('mouseup', closeDragElement);
        document.removeEventListener('mousemove', elementDrag);
      }
    }

    // Проверка доступной памяти
    function checkMemoryAndWarn() {
      if (memoryWarningShown) return;
      
      if (performance && performance.memory) {
        const totalJSHeapSize = performance.memory.totalJSHeapSize;
        const jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
        if (totalJSHeapSize > jsHeapSizeLimit * 0.7) {
          document.getElementById('memory-warning').style.display = 'block';
          memoryWarningShown = true;
        }
      } else if (navigator.deviceMemory && navigator.deviceMemory < 4) {
        document.getElementById('memory-warning').style.display = 'block';
        memoryWarningShown = true;
      }
    }

    // Функции обновления интерфейса
    function updateStatus(message) {
      document.getElementById('status-bar').textContent = message;
    }

    function updateCurrentFile(message) {
      const currentFileElement = document.getElementById('current-file');
      if (currentFileElement) {
        currentFileElement.textContent = message;
      }
    }

    function updateFileInfo(message) {
      const fileInfo = document.getElementById('file-info');
      if (fileInfo) {
        fileInfo.innerHTML += message;
      }
    }

    function showOverlay() {
      document.getElementById('overlay').style.display = 'block';
      document.getElementById('win95-loader').style.display = 'block';
      processingCancelled = false;
      lastProgress = 0;
      createdObjectURLs.forEach(url => URL.revokeObjectURL(url));
      createdObjectURLs = [];
    }

    function hideOverlay() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('win95-loader').style.display = 'none';
    }

    // Drag and drop обработчики
    function handleDragOver(e) {
      e.preventDefault();
      dragCounter++;
      document.getElementById('drop-zone').classList.add('dragover');
    }

    function handleDragLeave() {
      dragCounter--;
      if (dragCounter <= 0) {
        document.getElementById('drop-zone').classList.remove('dragover');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      dragCounter = 0;
      document.getElementById('drop-zone').classList.remove('dragover');
      
      if (e.dataTransfer.items) {
        const items = [];
        const queue = [];
        const entries = [];

        for (const item of e.dataTransfer.items) {
          if (item.kind === 'file') {
            const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
            if (entry) {
              entries.push(entry);
            }
          }
        }

        if (entries.length === 0) return;
        
        for (const entry of entries) {
          queue.push({ entry, path: '' });
        }
        
        processQueue(queue, items);
      } else if (e.dataTransfer.files.length > 0) {
        const items = Array.from(e.dataTransfer.files).map(file => ({
          file,
          path: file.name
        }));
        processItems(items);
      }
    }
    
    // Обработка очереди файлов/папок
    function processQueue(queue, items) {
      if (queue.length === 0) {
        processItems(items);
        return;
      }
      
      const { entry, path } = queue.shift();
      
      if (entry.isFile) {
        entry.file(file => {
          items.push({ file, path: path + file.name });
          processQueue(queue, items);
        });
      } else if (entry.isDirectory) {
        const dirReader = entry.createReader();
        dirReader.readEntries(entries => {
          for (const childEntry of entries) {
            queue.push({
              entry: childEntry,
              path: path + entry.name + '/'
            });
          }
          processQueue(queue, items);
        });
      } else {
        processQueue(queue, items);
      }
    }

    // Обработка отдельных файлов
    async function processFiles(files) {
      const items = Array.from(files).map(file => ({
        file,
        path: file.name
      }));
      await processItems(items);
    }

    // Обработка папки
    async function processFolder(files) {
      const items = [];
      
      for (const file of files) {
        const path = file.webkitRelativePath || file.name;
        items.push({ file, path });
      }
      
      await processItems(items);
    }

    // Инициализация AudioContext
    function initAudioContext() {
      if (!activeAudioContext) {
        activeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioContextInitialized = true;
      }
      return activeAudioContext;
    }

    // Основная функция обработки
    async function processItems(items) {
      if (items.length === 0) {
        updateStatus("No files to process");
        return;
      }
      
      const segmentContainer = document.getElementById('segment-container');
      const fileInfo = document.getElementById('file-info');
      const cancelButton = document.getElementById('cancel-button');
      const autoTrim = document.getElementById('auto-trim').checked;

      showOverlay();
      fileInfo.innerHTML = '<div>Processing started...</div>';
      cancelButton.disabled = false;
      
      updateStatus(`Processing ${items.length} item(s)`);

      const zip = new JSZip();
      
      let stereoOriginal = 0;
      let monoOriginal = 0;
      let totalOriginalSize = 0;
      let totalProcessedSize = 0;
      let processedCount = 0;
      let totalTrimmed = 0;

      segmentContainer.innerHTML = '';
      const totalSegments = 50;
      for (let i = 0; i < totalSegments; i++) {
        const seg = document.createElement('div');
        seg.className = 'progress-segment';
        segmentContainer.appendChild(seg);
      }

      currentProcessing = {
        cancel: () => {
          processingCancelled = true;
          if (activeAudioContext) {
            activeAudioContext.close();
            activeAudioContext = null;
          }
          cancelButton.disabled = true;
          updateStatus("Processing cancelled");
        }
      };

      const BATCH_SIZE = 5;
      const MAX_CONCURRENT = 3;
      
      for (let batchStart = 0; batchStart < items.length; batchStart += BATCH_SIZE) {
        if (processingCancelled) break;
        
        const batchEnd = Math.min(batchStart + BATCH_SIZE, items.length);
        const batchItems = items.slice(batchStart, batchEnd);
        
        const results = [];
        let running = 0;
        let indexInBatch = 0;
        
        while (indexInBatch < batchItems.length) {
          if (running < MAX_CONCURRENT) {
            const item = batchItems[indexInBatch];
            const globalIndex = batchStart + indexInBatch;
            indexInBatch++;
            running++;
            
            (async () => {
              try {
                const result = await processSingleItem(item, globalIndex, items.length, zip);
                if (result) {
                  results.push(result);
                }
              } catch (error) {
                handleProcessingError(error, item);
              } finally {
                running--;
              }
            })();
          } else {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
        }
        
        while (running > 0) {
          await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        for (const result of results) {
          if (!result) continue;
          
          processedCount++;
          totalOriginalSize += result.originalSize;
          totalProcessedSize += result.processedSize;
          totalTrimmed += result.trimmedSamples || 0;
          
          if (result.channels === 1) monoOriginal++;
          else if (result.channels === 2) stereoOriginal++;
          
          processedFiles.push({
            fileName: result.fileName,
            buffer: result.buffer,
            originalSize: result.originalSize,
            processedSize: result.processedSize
          });
        }
      }

      if (!processingCancelled) {
        segmentContainer.querySelectorAll('.progress-segment').forEach(seg => {
          seg.classList.add('active');
        });
      }

      try {
        if (processedCount > 0 && !processingCancelled) {
          const throttle = (func, limit) => {
            let lastFunc;
            let lastRan;
            return function() {
              const context = this;
              const args = arguments;
              if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
              } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(function() {
                  if ((Date.now() - lastRan) >= limit) {
                    func.apply(context, args);
                    lastRan = Date.now();
                  }
                }, limit - (Date.now() - lastRan));
              }
            }
          };
          
          const throttledProgress = throttle(progress => {
            updateProgressBar(0.8 + progress * 0.2);
          }, 100);
          
          const zipBlob = await zip.generateAsync({ 
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: { level: 6 }
          }, metadata => {
            const progress = metadata.percent / 100;
            updateStatus(`Compressing: ${metadata.percent.toFixed(1)}%`);
            throttledProgress(progress);
          });
          
          await updateProgressBar(1);
          
          const zipUrl = URL.createObjectURL(zipBlob);
          createdObjectURLs.push(zipUrl);
          
          const a = document.createElement('a');
          a.href = zipUrl;
          a.download = "ko2_processed_audio.zip";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          setTimeout(() => {
            URL.revokeObjectURL(zipUrl);
            createdObjectURLs = createdObjectURLs.filter(url => url !== zipUrl);
          }, 1000);
          
          const fidelity = getSelectedValue('fidelity');
          const channels = getSelectedValue('channels');
          
          fileInfo.innerHTML += `
            <div><b>Processed ${processedCount} files</b></div>
            <div>Original size: ${formatBytes(totalOriginalSize)}</div>
            <div>Processed size: ${formatBytes(totalProcessedSize)}</div>
            <div>Space saved: ${(100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1)}%</div>
          `;
          
          if (autoTrim && totalTrimmed > 0) {
            fileInfo.innerHTML += `<div>Total silence trimmed: ${(totalTrimmed/44100).toFixed(2)}s</div>`;
          }
          
          fileInfo.innerHTML += `
            <div>Fidelity: ${escapeHTML(fidelity.toUpperCase())}</div>
            <div>Channels: ${escapeHTML(channels)}</div>
            <div>Stereo: ${stereoOriginal}, Mono: ${monoOriginal}</div>
          `;
          
          updateStatus(`Processed ${processedCount} files. Space saved: ${(100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1)}%`);
        }
      } catch (error) {
        console.error('Error generating ZIP:', error);
        if (!processingCancelled) {
          handleProcessingError(error);
        }
      }

      if (!processingCancelled) {
        hideOverlay();
      }
      
      if (activeAudioContext) {
        activeAudioContext.close();
        activeAudioContext = null;
        audioContextInitialized = false;
      }
      
      currentProcessing = null;
    }

    async function processSingleItem(item, index, total, zip) {
      const file = item.file;
      let decoded, processed;
      let originalSize = file.size;
      let processedSize = 0;
      let trimmedSamples = 0;
      let fileName = '';
      let channels = 0;
      let originalExtension = file.name.split('.').pop().toLowerCase();
      
      try {
        updateCurrentFile(`Processing: ${escapeHTML(item.path)} (${index+1}/${total})`);
        updateFileInfo(`<div>Processing: ${escapeHTML(item.path)}</div>`);
        
        if (!isSupportedAudioType(file.type, file.name)) {
          throw new Error(`Unsupported file type: ${file.type || file.name.split('.').pop()}`);
        }
        
        if (file.size > 100 * 1024 * 1024) {
          throw new Error(`File size exceeds 100MB limit (${(file.size/(1024*1024)).toFixed(1)}MB)`);
        }
        
        if (index === 0) {
          showPreview(file);
        }
        
        if (!audioContextInitialized) {
          initAudioContext();
        }
        
        const arrayBuffer = await file.arrayBuffer();
        if (processingCancelled) return null;
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        decoded = await audioContext.decodeAudioData(arrayBuffer);
        if (processingCancelled) return null;
        
        channels = decoded.numberOfChannels;
        
        const fidelity = getSelectedValue('fidelity');
        const channelsSetting = getSelectedValue('channels');
        const autoTrim = document.getElementById('auto-trim').checked;
        
        processed = await processAudio(decoded, fidelity, channelsSetting);
        if (processingCancelled) return null;
        
        if (autoTrim) {
          const beforeLength = processed.length;
          processed = trimSilence(processed);
          const afterLength = processed.length;
          trimmedSamples = beforeLength - afterLength;
          
          updateFileInfo(`<div>Trimmed: ${(trimmedSamples/processed.sampleRate).toFixed(2)}s silence</div>`);
        }
        
        fileName = item.path;
        if (fileName.includes('/')) {
          const parts = fileName.split('/');
          const lastPart = parts.pop();
          if (lastPart.includes('.')) {
            const nameWithoutExt = lastPart.substring(0, lastPart.lastIndexOf('.'));
            parts.push(nameWithoutExt + '_ko2.' + originalExtension);
          } else {
            parts.push(lastPart + '_ko2.' + originalExtension);
          }
          fileName = parts.join('/');
        } else {
          if (fileName.includes('.')) {
            fileName = fileName.substring(0, fileName.lastIndexOf('.')) + '_ko2.' + originalExtension;
          } else {
            fileName = fileName + '_ko2.' + originalExtension;
          }
        }
        
        let outputExtension = originalExtension;
        let mimeType = getMimeType(originalExtension);
        
        if (originalExtension !== 'wav') {
          if (typeof MediaRecorder === 'undefined' || !MediaRecorder.isTypeSupported(mimeType)) {
            outputExtension = 'wav';
            fileName = fileName.replace(/\.[^/.]+$/, '') + '.wav';
            updateFileInfo(`<div class="file-warning">Browser does not support ${originalExtension} encoding. Using WAV format instead.</div>`);
          }
        }
        
        const outputBlob = await audioBufferToBlob(processed, outputExtension);
        processedSize = outputBlob.size;
        
        zip.file(fileName, outputBlob);
        
        const originalSizeKB = (originalSize / 1024).toFixed(1);
        const processedSizeKB = (processedSize / 1024).toFixed(1);
        const sizeDifference = processedSize - originalSize;
        let sizeInfo;
        
        if (sizeDifference > 0) {
          sizeInfo = `INCREASED by ${(sizeDifference/1024).toFixed(1)}KB`;
        } else {
          sizeInfo = `DECREASED by ${(-sizeDifference/1024).toFixed(1)}KB`;
        }
        
        updateFileInfo(`
          <div>Processed: ${escapeHTML(fileName)}</div>
          <div>Original: ${originalSizeKB}KB → Processed: ${processedSizeKB}KB</div>
          <div>${sizeInfo}</div>
        `);
        
        await updateProgressBar((index + 1) / total);
        
        return {
          buffer: processed,
          fileName: fileName,
          originalSize: originalSize,
          processedSize: processedSize,
          trimmedSamples: trimmedSamples,
          channels: channels
        };
        
      } catch (error) {
        console.error('Error processing file:', error);
        if (!processingCancelled) {
          handleProcessingError(error, item);
        }
        return null;
      } finally {
        decoded = null;
        processed = null;
        await new Promise(resolve => setTimeout(resolve, 0));
        if (window.gc) window.gc();
      }
    }

    // Показать предпрослушивание
    function showPreview(file) {
      const previewContainer = document.getElementById('preview-container');
      const previewAudio = document.getElementById('preview-audio');
      
      if (currentPreviewUrl) {
        URL.revokeObjectURL(currentPreviewUrl);
        currentPreviewUrl = null;
      }
      
      currentPreviewUrl = URL.createObjectURL(file);
      previewAudio.src = currentPreviewUrl;
      
      previewContainer.style.display = 'block';
      
      generateWaveformPreview(file);
    }
    
    // Генерация упрощенной waveform
    async function generateWaveformPreview(file) {
      const canvas = document.getElementById('preview-waveform');
      const ctx = canvas.getContext('2d');
      
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      const width = canvas.width;
      const height = canvas.height;
      
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        const channelData = audioBuffer.getChannelData(0);
        const step = Math.ceil(channelData.length / width);
        
        ctx.fillStyle = '#0f0';
        
        for (let i = 0; i < width; i++) {
          const start = Math.floor(i * step);
          const end = Math.min(Math.floor((i + 1) * step), channelData.length);
          
          let min = 0;
          let max = 0;
          
          for (let j = start; j < end; j++) {
            const value = channelData[j];
            if (value < min) min = value;
            if (value > max) max = value;
          }
          
          const h = (max - min) * height;
          const y = (1 - max) * height / 2;
          
          ctx.fillRect(i, y, 1, h);
        }
        
        audioContext.close();
      } catch (error) {
        console.error('Waveform generation error:', error);
        ctx.fillStyle = '#f00';
        ctx.font = '12px Arial';
        ctx.fillText('Waveform preview unavailable', 10, 20);
      }
    }

    // Функция для получения MIME-типа по расширению
    function getMimeType(extension) {
      const types = {
        'wav': 'audio/wav',
        'mp3': 'audio/mpeg',
        'ogg': 'audio/ogg',
        'flac': 'audio/flac',
        'aac': 'audio/aac',
        'm4a': 'audio/mp4'
      };
      return types[extension] || 'audio/wav';
    }

    // Конвертация AudioBuffer в Blob с нужным форматом
    async function audioBufferToBlob(audioBuffer, extension) {
      if (extension === 'wav') {
        return audioBufferToWav(audioBuffer);
      } else {
        return new Promise((resolve, reject) => {
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const dest = audioContext.createMediaStreamDestination();
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(dest);
            source.start();
            
            const mimeType = getMimeType(extension);
            const recorder = new MediaRecorder(dest.stream, {
              mimeType: mimeType
            });
            
            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
              const blob = new Blob(chunks, { type: mimeType });
              resolve(blob);
              audioContext.close();
            };
            
            recorder.onerror = (e) => {
              reject(e.error || new Error('MediaRecorder error'));
              audioContext.close();
            };
            
            recorder.start();
            setTimeout(() => {
              recorder.stop();
              source.stop();
            }, audioBuffer.duration * 1000 + 500);
          } catch (error) {
            reject(error);
          }
        });
      }
    }

    // Оптимизированная функция обрезки тишины
    function trimSilence(audioBuffer, thresholdDb = -40, minSilenceDuration = 0.1) {
      if (audioBuffer.length === 0) return audioBuffer;
      
      const threshold = Math.pow(10, thresholdDb / 20);
      const sampleRate = audioBuffer.sampleRate;
      const minSilenceSamples = Math.floor(minSilenceDuration * sampleRate);
      const channelData = audioBuffer.getChannelData(0);
      const length = channelData.length;
      
      const blockSize = 1024;
      let startIndex = 0;
      let endIndex = length - 1;
      
      for (let i = 0; i < length; i += blockSize) {
        let hasSound = false;
        const blockEnd = Math.min(i + blockSize, length);
        
        for (let j = i; j < blockEnd; j++) {
          if (Math.abs(channelData[j]) > threshold) {
            startIndex = Math.max(0, j - blockSize);
            hasSound = true;
            break;
          }
        }
        
        if (hasSound) break;
      }
      
      for (let i = length - 1; i >= 0; i -= blockSize) {
        let hasSound = false;
        const blockStart = Math.max(0, i - blockSize);
        
        for (let j = i; j >= blockStart; j--) {
          if (Math.abs(channelData[j]) > threshold) {
            endIndex = Math.min(length - 1, j + blockSize);
            hasSound = true;
            break;
          }
        }
        
        if (hasSound) break;
      }
      
      startIndex = findExactStart(channelData, startIndex, threshold);
      endIndex = findExactEnd(channelData, endIndex, threshold);
      
      if (startIndex >= endIndex) {
        return createEmptyBuffer(audioBuffer);
      }
      
      startIndex = Math.max(0, startIndex - Math.floor(0.05 * sampleRate));
      endIndex = Math.min(length - 1, endIndex + Math.floor(0.05 * sampleRate));
      
      const newLength = endIndex - startIndex + 1;
      const newBuffer = new AudioBuffer({
        length: newLength,
        sampleRate: audioBuffer.sampleRate,
        numberOfChannels: audioBuffer.numberOfChannels
      });
      
      for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
        const sourceData = audioBuffer.getChannelData(ch);
        const targetData = newBuffer.getChannelData(ch);
        targetData.set(sourceData.subarray(startIndex, endIndex + 1));
      }
      
      return newBuffer;
    }
    
    function createEmptyBuffer(buffer) {
      return new AudioBuffer({
        numberOfChannels: buffer.numberOfChannels,
        length: 1,
        sampleRate: buffer.sampleRate
      });
    }

    function findExactStart(data, roughStart, threshold) {
      for (let i = roughStart; i >= 0; i--) {
        if (Math.abs(data[i]) > threshold) {
          return i;
        }
      }
      return roughStart;
    }

    function findExactEnd(data, roughEnd, threshold) {
      for (let i = roughEnd; i < data.length; i++) {
        if (Math.abs(data[i]) > threshold) {
          return i;
        }
      }
      return roughEnd;
    }

    // Форматирование размера файла
    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      else return (bytes / 1048576).toFixed(1) + ' MB';
    }

    // Обработка ошибок
    function handleProcessingError(error, item) {
      console.error('Processing error:', error);
      
      const errorMessage = error.message || 'Unknown error';
      const fileName = item?.file?.name || 'unknown file';
      const errorDetails = `Error: ${errorMessage} (${fileName})`;
      
      document.getElementById('file-info').innerHTML += `
        <div class="file-error">
          <strong>Error processing:</strong> ${escapeHTML(fileName)}<br>
          ${escapeHTML(errorMessage)}
        </div>
      `;
      
      updateStatus(errorDetails);
      
      if (error.message.includes('memory') || error.message.includes('allocation')) {
        if (activeAudioContext) {
          activeAudioContext.close();
          activeAudioContext = null;
        }
        document.getElementById('memory-warning').style.display = 'block';
        memoryWarningShown = true;
      }
    }

    // Проверка поддерживаемых форматов
    function isSupportedAudioType(mimeType, fileName) {
      const supportedTypes = [
        'audio/wav', 'audio/wave', 'audio/x-wav',
        'audio/mpeg', 'audio/mp3',
        'audio/ogg', 'audio/vorbis',
        'audio/aac', 'audio/aacp',
        'audio/flac', 'audio/x-flac'
      ];
      
      const ext = fileName.split('.').pop().toLowerCase();
      const supportedExts = ['wav', 'mp3', 'ogg', 'aac', 'flac', 'm4a'];
      
      return supportedTypes.includes(mimeType) || supportedExts.includes(ext);
    }

    // Безопасное декодирование аудио
    async function decodeAudioSafe(arrayBuffer) {
      return new Promise((resolve, reject) => {
        if (!activeAudioContext) {
          reject(new Error("AudioContext is not available"));
          return;
        }
        
        if (activeAudioContext.decodeAudioData.length === 1) {
          resolve(activeAudioContext.decodeAudioData(arrayBuffer));
        } else {
          activeAudioContext.decodeAudioData(
            arrayBuffer,
            buffer => resolve(buffer),
            error => reject(new Error(`Audio decoding failed: ${error.message}`))
          );
        }
      });
    }

    // Аудио обработка
    function getSelectedValue(name) {
      const group = document.querySelector(`.win95-list[data-group="${name}"]`);
      return group?.querySelector('.list-item.selected')?.dataset.value || 'cd';
    }

    function getFidelitySettings(fidelity) {
      switch (fidelity) {
        case 'sp8': return { sampleRate: 22050, bitDepth: 8 };
        case 'sp16': return { sampleRate: 22050, bitDepth: 16 };
        case 'sk': return { sampleRate: 9000, bitDepth: 8 };
        default: return { sampleRate: 44100, bitDepth: 16 };
      }
    }

    async function processAudio(buffer, fidelity, channels) {
      if (buffer.length === 0) return buffer;
      
      const fidelitySettings = getFidelitySettings(fidelity);
      const targetChannels = channels === 'mono' ? 1 : 2;
      
      const speedFactor = 2.0;
      
      const converted = await convertChannels(buffer, targetChannels);
      
      const downsampleRate = fidelitySettings.sampleRate;
      return await applySpeedAndFidelity(converted, speedFactor, downsampleRate);
    }

    async function convertChannels(buffer, targetChannels) {
      if (buffer.length === 0) return buffer;
      if (buffer.numberOfChannels === targetChannels) return buffer;

      const ctx = new OfflineAudioContext(
        targetChannels, 
        buffer.length, 
        buffer.sampleRate
      );
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      
      if (targetChannels === 1 && buffer.numberOfChannels > 1) {
        const merger = ctx.createChannelMerger(1);
        const splitter = ctx.createChannelSplitter(buffer.numberOfChannels);
        source.connect(splitter);
        
        const gain = ctx.createGain();
        gain.gain.value = 1 / buffer.numberOfChannels;
        
        for (let i = 0; i < buffer.numberOfChannels; i++) {
          splitter.connect(gain, i);
        }
        
        gain.connect(merger, 0, 0);
        merger.connect(ctx.destination);
      } 
      else if (targetChannels === 2 && buffer.numberOfChannels === 1) {
        const merger = ctx.createChannelMerger(2);
        source.connect(merger, 0, 0);
        source.connect(merger, 0, 1);
        merger.connect(ctx.destination);
      } 
      else {
        source.connect(ctx.destination);
      }
      
      source.start();
      const result = await ctx.startRendering();
      
      source.disconnect();
      if (ctx.destination) ctx.destination.disconnect();
      
      return result;
    }

    async function applySpeedAndFidelity(buffer, speed, sampleRate) {
      if (buffer.length === 0) return buffer;
      
      const duration = buffer.duration / speed;
      const ctx = new OfflineAudioContext(
        buffer.numberOfChannels,
        Math.ceil(duration * sampleRate),
        sampleRate
      );
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.playbackRate.value = speed;
      source.connect(ctx.destination);
      source.start();
      const result = await ctx.startRendering();
      
      source.disconnect();
      if (ctx.destination) ctx.destination.disconnect();
      
      return result;
    }

    function audioBufferToWav(buffer) {
      const pitch = -12;
      const release = 255;
      const playmode = 1;
      
      const ko2Chunk = writeKO2Chunk(pitch, release, playmode);
      
      const fidelity = getSelectedValue('fidelity');
      const fidelitySettings = getFidelitySettings(fidelity);
      const bitDepth = fidelitySettings.bitDepth;
      
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const length = buffer.length;
      const bytesPerSample = bitDepth === 8 ? 1 : 2;
      const blockAlign = numChannels * bytesPerSample;
      const dataLength = length * blockAlign;
      
      const chunkSize = 36 + dataLength + ko2Chunk.byteLength;
      const riffSize = chunkSize;
      
      const header = new ArrayBuffer(44);
      const view = new DataView(header);
      
      writeString(view, 0, 'RIFF');
      view.setUint32(4, riffSize, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, dataLength, true);
      
      let audioData;
      if (bitDepth === 8) {
        audioData = new Uint8Array(length * numChannels);
        let offset = 0;
        for (let i = 0; i < length; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            const sample = buffer.getChannelData(ch)[i];
            audioData[offset] = Math.floor((sample + 1.0) * 127.5 + 0.5);
            offset++;
          }
        }
      } else {
        audioData = new Int16Array(length * numChannels);
        let offset = 0;
        for (let i = 0; i < length; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
            const val = Math.floor(sample * (sample < 0 ? 32768 : 32767));
            audioData[offset] = Math.max(-32768, Math.min(32767, val));
            offset++;
          }
        }
      }
      
      return new Blob([header, audioData.buffer, ko2Chunk], { type: 'audio/wav' });
    }

    function writeKO2Chunk(pitch, release, playmode) {
      const buffer = new ArrayBuffer(12);
      const view = new DataView(buffer);
      
      writeString(view, 0, 'ko2 ');
      view.setUint32(4, 4, true);
      view.setInt8(8, pitch);
      view.setUint16(9, release, true);
      view.setUint8(11, playmode);
      
      return buffer;
    }

    function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    }
    
    // Экранирование HTML
    function escapeHTML(str) {
      return str.replace(/[&<>"']/g, 
        tag => ({
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        }[tag] || tag));
    }

    // Вспомогательные функции
    function updateProgressBar(progress) {
      return new Promise(resolve => {
        progress = Math.max(0, Math.min(1, progress));
        
        const segments = document.querySelectorAll('.progress-segment');
        const segmentsToActivate = Math.floor(progress * segments.length);
        
        for (let i = 0; i < segments.length; i++) {
          const shouldBeActive = i < segmentsToActivate;
          const isActive = segments[i].classList.contains('active');
          
          if (shouldBeActive && !isActive) {
            segments[i].classList.add('active');
          } else if (!shouldBeActive && isActive) {
            segments[i].classList.remove('active');
          }
        }
        
        lastProgress = progress;
        setTimeout(resolve, 20);
      });
    }

    // Очистка при закрытии
    window.addEventListener('beforeunload', () => {
      createdObjectURLs.forEach(url => URL.revokeObjectURL(url));
      if (currentPreviewUrl) URL.revokeObjectURL(currentPreviewUrl);
      if (activeAudioContext) {
        activeAudioContext.close();
      }
    });
  </script>
</body>
</html>
