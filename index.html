<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>SpeedUpperCut</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="24" y="40" width="16" height="16" fill="#e53935" stroke="black" stroke-width="2"/><rect x="26" y="44" width="12" height="4" fill="#b71c1c"/><polygon points="32,32 28,28 30,24 34,26 36,22 38,30" fill="orange" stroke="black" stroke-width="1"/></svg>'>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/wavesurfer.js@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
  <style>
    :root { --glow-color: #ff3333; --primary-blue: #000080; --win-gray: #c0c0c0; --win-light: #ffffff; --win-dark: #808080; }
    body { background: #008080; font-family: 'Courier New', monospace; margin: 0; padding: 20px; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; overflow-x: hidden; background-image: radial-gradient(circle at 1px 1px, var(--win-dark) 1px, transparent 0), radial-gradient(circle at 1px 1px, var(--win-dark) 1px, transparent 0); background-size:4px 4px; background-position:0 0, 2px 2px; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    .desktop-icon { position: absolute; width: 80px; text-align: center; color: white; text-shadow: 1px 1px 1px black; cursor: pointer; padding: 4px; user-select: none; transition: transform 0.2s; }
    .desktop-icon:hover { background: rgba(255, 255, 255, 0.2); transform: scale(1.05); }
    .window { width: 100%; max-width: 480px; background: var(--win-gray); border: 2px solid; border-top-color: var(--win-light); border-left-color: var(--win-light); border-right-color: var(--win-dark); border-bottom-color: var(--win-dark); box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); padding: 0; box-sizing: border-box; position: relative; z-index: 100; }
    .title-bar { background: var(--primary-blue); color: #fff; padding: 4px 8px; font-size: 14px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--win-gray); cursor: move; user-select: none; }
    .title-bar button { width: 20px; height: 20px; border: none; background: var(--win-gray); cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; font-family: Arial, sans-serif; margin-left: 4px; border: 1px solid; border-top-color: var(--win-light); border-left-color: var(--win-light); border-right-color: var(--win-dark); border-bottom-color: var(--win-dark); }
    .title-bar button.minimize { font-size: 18px; line-height: 12px; }
    .title-bar button.close { font-size: 14px; }
    .title-bar button:active { border-top-color: var(--win-dark); border-left-color: var(--win-dark); border-right-color: var(--win-light); border-bottom-color: var(--win-light); }
    .content { padding: 12px; font-size: 14px; color: #000; }
    .drop-zone { border: 2px dashed #000; padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.3); margin-top: 12px; position: relative; cursor: pointer; border-style: dotted; border-color: var(--win-dark); }
    .drop-zone.dragover { background: rgba(0, 128, 0, 0.3); }
    .drop-zone input[type="file"] { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; top: 0; left: 0; }
    .drop-zone span { pointer-events: none; font-size: 16px; display: block; margin-top: 10px; }
    #file-info { margin-top: 10px; font-size: 14px; text-align: left; background: #fff; border: 2px inset var(--win-dark); padding: 10px; max-height: 200px; overflow-y: auto; }
    button { min-height: 44px; padding: 10px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 16px; border: 2px outset var(--win-gray); background: var(--win-gray); color: #000; }
    button:active { border-style: inset; }
    #overlay { display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.4); z-index: 1000; }
    #win95-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 320px; padding: 12px; background: var(--win-gray); font-family: 'Courier New', monospace; font-size: 14px; color: #000; z-index: 1001; border: 2px solid; border-top-color: var(--win-light); border-left-color: var(--win-light); border-right-color: var(--win-dark); border-bottom-color: var(--win-dark); }
    .progress-bar-container { background: #fff; border: 2px inset var(--win-dark); height: 24px; margin-top: 8px; display: flex; padding: 2px; gap: 1px; justify-content: flex-start; }
    .progress-segment { width: 8px; height: 100%; background: var(--win-gray); transition: background-color 0.3s ease; }
    .progress-segment.active { background: linear-gradient(to bottom, #1a5fb4, #0d52a8); box-shadow: 0 0 5px var(--glow-color); }
    .win95-inset { border: 2px inset var(--win-dark); background: var(--win-gray); padding: 6px; margin-bottom: 6px; }
    .win95-list { border: 2px inset var(--win-dark); background: #fff; padding: 4px; font-family: 'Courier New', monospace; height: 100px; overflow-y: auto; }
    .list-item { padding: 8px 6px; cursor: pointer; user-select: none; font-size: 13px; }
    .list-item:hover { background: var(--primary-blue); color: white; transition: background 0.2s ease; }
    .list-item.selected { background: var(--primary-blue); color: white; }
    .wave-container { margin-bottom: 20px; border: 2px inset var(--win-dark); padding: 10px; background: #e0e0e0; position: relative; }
    .wave-title { font-family: 'Courier New', monospace; font-size: 14px; margin-bottom: 6px; word-break: break-word; font-weight: bold; text-align: center; }
    .wave-element-container { width: 100%; height: 150px; background: #000; margin-bottom: 10px; position: relative; overflow: hidden; padding: 10px 0; box-sizing: border-box; }
    .wave-element { width: 100%; height: 100%; }
    .wave-button { font-family: 'Courier New', monospace; padding: 8px; background: var(--win-gray); border: 2px outset var(--win-gray); cursor: pointer; min-width: 80px; }
    .wave-button:active { border-style: inset; }
    .render-error { color: red; font-size: 13px; padding: 10px; background: #ffe6e6; border: 1px solid #ff9999; }
    .taskbar { position: fixed; bottom: 0; left: 0; right: 0; background: var(--win-gray); height: 36px; border-top: 2px solid var(--win-light); display: flex; align-items: center; padding: 0 8px; z-index: 90; }
    .start-button { padding: 4px 8px; background: var(--win-gray); border: 2px outset var(--win-gray); font-weight: bold; cursor: pointer; display: flex; align-items: center; gap: 4px; }
    .status-bar { margin-left: auto; padding: 0 8px; font-size: 14px; }
    .window-controls { display: flex; }
    .button-group { display: flex; gap: 10px; margin-top: 10px; }
    .button-group button { flex: 1; }
    #cancel-button { margin-top: 10px; width: 100%; padding: 10px; background: var(--win-gray); border: 2px outset var(--win-gray); color: #000; font-family: 'Courier New', monospace; font-size: 16px; cursor: pointer; }
    #cancel-button:active { border-style: inset; }
    .supported-formats { margin-top: 8px; font-size: 12px; color: #666; }
    .file-error { color: #d32f2f; background-color: #ffcdd2; border: 1px solid #f44336; padding: 8px; margin: 8px 0; border-radius: 2px; font-size: 13px; }
    .memory-warning { color: #ff6f00; background-color: #fff3e0; border: 1px solid #ff9800; padding: 8px; margin: 8px 0; border-radius: 2px; font-size: 13px; display: none; }
    .mobile-warning { color: #1976d2; background-color: #bbdefb; border: 1px solid #2196f3; padding: 8px; margin: 8px 0; border-radius: 2px; font-size: 13px; display: none; }
    .info-panel { background: #fff; border: 2px inset var(--win-dark); padding: 10px; margin-top: 10px; font-size: 13px; max-height: 150px; overflow-y: auto; }
    .trim-control { display: flex; align-items: center; gap: 8px; margin-top: 10px; margin-bottom: 10px; }
    .wave-window { position: absolute; width: 500px; background: var(--win-gray); border: 2px solid; border-top-color: var(--win-light); border-left-color: var(--win-light); border-right-color: var(--win-dark); border-bottom-color: var(--win-dark); box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); padding: 0; box-sizing: border-box; z-index: 101; top: 100px; left: 100px; }
    .preview-controls { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
    .wave-element-container:empty::after { content: "Loading..."; color: var(--win-dark); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .format-warning { color: #ff6f00; background-color: #fff3e0; border: 1px solid #ff9800; padding: 8px; margin: 8px 0; border-radius: 2px; font-size: 13px; }
    .mobile-fallback { text-align: center; padding: 15px; background: white; }
    .mobile-fallback audio { width: 100%; margin: 10px 0; }
    .processing { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
    @media (max-width: 768px) { body { padding: 10px; } .window { width: 95vw; max-width: none; top: 10px; transform: scale(0.98); } .wave-element-container { height: 100px !important; } .desktop-icon { transform: scale(1.3); top: 10px !important; left: 5px !important; } .win95-list { height: 80px; } .list-item { padding: 6px 4px; font-size: 12px; } .wave-window { width: 90vw; left: 5vw; top: 20px; } .preview-controls { flex-direction: column; align-items: center; } .wave-button { min-width: 150px; } button { min-height: 54px; font-size: 18px; } }
    @media (max-width: 768px) and (orientation: landscape) { .wave-element-container { height: 100px !important; } }
  </style>
</head>
<body>
  <div class="desktop-icon" style="top:20px;left:30px" onclick="document.querySelector('.window').style.display='block'">
    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4Ij48cmVjdCB4PSIyNCIgeT0iNDAiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0iI2U1MzkzNSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PHJlY3QgeD0iMjYiIHk9IjQ0IiB3aWR0aD0iMTIiIGhlaWdodD0iNCIgZmlsbD0iI2I3MWMxYyIvPjxwb2x5Z29uIHBvaW50cz0iMzIsMzIgMjgsMjggMzAsMjQgMzQsMjYgMzYsMjIgMzgsMzAiIGZpbGw9Im9yYW5nZSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9zdmc+" width="48" height="48">
    <div>KO II Tool</div>
  </div>
  
  <div class="window">
    <div class="title-bar">
      <span>SpeedUpperCut</span>
      <div class="window-controls">
        <button class="minimize" title="Minimize">_</button>
        <button class="close" title="Close">×</button>
      </div>
    </div>
    <div class="content">
      <div class="memory-warning" id="memory-warning">
        <i class="fas fa-exclamation-triangle"></i> Processing large files may use significant memory. Close other tabs.
      </div>
      
      <div class="mobile-warning" id="mobile-warning">
        <i class="fas fa-mobile-alt"></i> Processing on mobile may be slow. Use small files for best results.
      </div>
      
      <div class="format-warning">
        <i class="fas fa-info-circle"></i> Files will be saved in their original format (MP3, WAV, etc.)
      </div>
      
      <div style="display:flex;gap:8px;margin-bottom:10px">
        <div class="win95-inset" style="flex:1">
          <label>FIDELITY</label><br>
          <div class="win95-list" data-group="fidelity">
            <div data-value="cd" class="list-item selected">CD (16-bit, 44.1kHz)</div>
            <div data-value="sp8" class="list-item">SP-1200 (8-bit, 22kHz)</div>
            <div data-value="sp16" class="list-item">SP-1200 (16-bit, 22kHz)</div>
            <div data-value="sk" class="list-item">SK-1 (8-bit, 9kHz)</div>
          </div>
        </div>
        <div class="win95-inset" style="flex:1">
          <label>CHANNELS</label><br>
          <div class="win95-list" data-group="channels">
            <div data-value="stereo" class="list-item selected">Stereo</div>
            <div data-value="mono" class="list-item">Mono</div>
          </div>
        </div>
      </div>
      
      <div class="trim-control">
        <input type="checkbox" id="auto-trim" checked style="width:16px;height:16px">
        <label for="auto-trim">Auto-trim silence at start/end</label>
      </div>
      
      <div class="drop-zone" id="drop-zone">
        <i class="fas fa-cloud-upload-alt" style="font-size:36px"></i>
        <input type="file" id="audio-upload" accept=".wav,.mp3,.aac,.ogg,.flac,audio/*" multiple>
        <input type="file" id="folder-upload" webkitdirectory directory multiple style="display:none">
        <span>DRAG AND DROP OR SELECT AUDIO FILES/FOLDERS</span>
        <div class="supported-formats">Supported: WAV, MP3, AAC, OGG, FLAC</div>
      </div>
      
      <div class="button-group">
        <button id="select-file-button">Select Files</button>
        <button id="select-folder-button">Select Folder</button>
        <button id="clear-button">Clear List</button>
      </div>
      
      <div class="info-panel" id="file-info">
        <div>Drop or select audio files/folders to process</div>
        <div>Files will be sped up 2x to save space</div>
        <div>Auto-trim removes silence at start and end</div>
        <div>Folder structure will be preserved in output</div>
        <div>Files will be saved in their original format</div>
        <div>KO II will convert files during import</div>
      </div>
    </div>
  </div>

  <div id="overlay">
    <div id="win95-loader">
      <div id="processing-title">Processing Audio Files...</div>
      <div class="progress-bar-container" id="segment-container"></div>
      <div id="current-file">Preparing...</div>
      <button id="cancel-button">Cancel Processing</button>
    </div>
  </div>

  <div class="taskbar">
    <div class="start-button">
      <i class="fas fa-bars"></i> Start
    </div>
    <div class="status-bar" id="status-bar">Ready</div>
  </div>

  <script>
    const MAX_FILE_SIZE = 50 * 1024 * 1024;
    const MAX_PREVIEW_WINDOWS = 3;
    const MAX_WORKERS = navigator.hardwareConcurrency || 2;
    
    let activeAudioContext = null;
    let createdObjectURLs = [];
    let dragCounter = 0;
    let processingCancelled = false;
    let currentProcessing = null;
    let lastProgress = 0;
    let windowZIndex = 100;
    let waveWindows = [];
    let audioContextResumed = false;
    let memoryWarningShown = false;
    let workerPool = [];
    let workerTasks = {};

    class Mp3Encoder {
      constructor(channels, sampleRate, bitrate) {
        if (typeof lamejs === 'undefined') {
          throw new Error('LameJS library not loaded! MP3 encoding unavailable.');
        }
        this.channels = channels;
        this.sampleRate = sampleRate;
        this.bitrate = bitrate;
        this.lame = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
      }

      encode(audioBuffer) {
        const [left, right] = this.getAudioData(audioBuffer);
        const sampleBlockSize = 1152;
        const leftSamples = new Int16Array(sampleBlockSize);
        const rightSamples = new Int16Array(sampleBlockSize);
        const mp3Data = [];

        for (let i = 0; i < left.length; i += sampleBlockSize) {
          const leftChunk = left.subarray(i, i + sampleBlockSize);
          const rightChunk = this.channels > 1 ? right.subarray(i, i + sampleBlockSize) : leftChunk;

          for (let j = 0; j < leftChunk.length; j++) {
            const sampleLeft = Math.max(-1, Math.min(1, leftChunk[j]));
            leftSamples[j] = sampleLeft < 0 ? Math.round(sampleLeft * 32768) : Math.round(sampleLeft * 32767);

            if (this.channels > 1) {
              const sampleRight = Math.max(-1, Math.min(1, rightChunk[j]));
              rightSamples[j] = sampleRight < 0 ? Math.round(sampleRight * 32768) : Math.round(sampleRight * 32767);
            }
          }

          const mp3buf = this.lame.encodeBuffer(
            leftSamples.subarray(0, leftChunk.length),
            this.channels > 1 ? rightSamples.subarray(0, leftChunk.length) : undefined
          );

          if (mp3buf.length > 0) {
            mp3Data.push(new Int8Array(mp3buf));
          }
        }

        const lastChunk = this.lame.flush();
        if (lastChunk.length > 0) {
          mp3Data.push(new Int8Array(lastChunk));
        }

        return new Blob(mp3Data, { type: 'audio/mp3' });
      }

      getAudioData(audioBuffer) {
        const left = audioBuffer.getChannelData(0);
        let right = new Float32Array(audioBuffer.length);
        if (audioBuffer.numberOfChannels > 1) {
          right = audioBuffer.getChannelData(1);
        }
        return [left, right];
      }
    }

    document.addEventListener('DOMContentLoaded', initApp);

    function initApp() {
      if (isMobile()) {
        document.getElementById('mobile-warning').style.display = 'block';
        document.getElementById('mobile-warning').innerHTML += '<p>Recommended: Use files under 2 minutes</p>';
        document.querySelectorAll('.wave-element-container').forEach(el => el.style.height = '100px');
        document.querySelectorAll('button').forEach(b => {
          b.style.minHeight = '54px';
          b.style.fontSize = '18px';
        });
      }
      
      initWorkerPool();
      checkMemoryAndWarn();
      setupEventListeners();
      updateStatus("Ready to process files");
    }

    function initWorkerPool() {
      for (let i = 0; i < MAX_WORKERS; i++) {
        const worker = new Worker('worker.js');
        worker.onmessage = handleWorkerMessage;
        workerPool.push(worker);
      }
    }

    function handleWorkerMessage(e) {
      const { id, type, progress, result, error } = e.data;
      const task = workerTasks[id];
      
      if (!task) return;
      
      if (type === 'progress') {
        task.progress = progress;
        updateProgressBar(task);
      } 
      else if (type === 'result') {
        task.resolve(result);
        delete workerTasks[id];
      } 
      else if (type === 'error') {
        task.reject(new Error(error));
        delete workerTasks[id];
      }
    }

    function processWithWorker(file, path, index, total) {
      return new Promise((resolve, reject) => {
        if (workerPool.length === 0 || processingCancelled) {
          reject(new Error('No available workers or processing cancelled'));
          return;
        }
        
        const worker = workerPool.pop();
        const taskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        workerTasks[taskId] = {
          resolve,
          reject,
          progress: 0,
          index,
          total
        };
        
        const message = {
          id: taskId,
          type: 'process',
          file,
          path,
          settings: {
            fidelity: getSelectedValue('fidelity'),
            channels: getSelectedValue('channels'),
            trim: document.getElementById('auto-trim').checked
          }
        };
        
        worker.postMessage(message, [file]);
      });
    }

    function setupEventListeners() {
      document.querySelectorAll('.win95-list').forEach(group => {
        group.addEventListener('click', e => {
          if (e.target.classList.contains('list-item')) {
            group.querySelectorAll('.list-item').forEach(item => item.classList.remove('selected'));
            e.target.classList.add('selected');
          }
        });
      });

      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('audio-upload');
      const folderInput = document.getElementById('folder-upload');
      const selectFileButton = document.getElementById('select-file-button');
      const selectFolderButton = document.getElementById('select-folder-button');
      const clearButton = document.getElementById('clear-button');
      const cancelButton = document.getElementById('cancel-button');

      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleDrop);
      dropZone.addEventListener('touchmove', e => {
        e.preventDefault();
        dragCounter++;
        dropZone.classList.add('dragover');
      }, { passive: false });
      dropZone.addEventListener('touchend', handleDragLeave);

      selectFileButton.addEventListener('click', () => {
        fileInput.click();
        activateAudio();
      });
      selectFolderButton.addEventListener('click', () => {
        folderInput.click();
        activateAudio();
      });
      clearButton.addEventListener('click', () => {
        document.getElementById('file-info').innerHTML = `
          <div>Drop or select audio files/folders to process</div>
          <div>Files will be sped up 2x to save space</div>
          <div>Auto-trim removes silence at start and end</div>
          <div>Folder structure will be preserved in output</div>
          <div>Files will be saved in their original format</div>
          <div>KO II will convert files during import</div>
        `;
        updateStatus("File list cleared");
      });

      fileInput.addEventListener('change', async e => {
        updateStatus(`Files selected: ${e.target.files.length}`);
        updateFileInfo(`<div>Selected ${e.target.files.length} file(s). Processing...</div>`);
        await ensureAudioContext();
        processFiles(e.target.files);
        e.target.value = null;
      });

      folderInput.addEventListener('change', async e => {
        updateStatus(`Folder selected with ${e.target.files.length} files`);
        updateFileInfo(`<div>Folder selected. Processing...</div>`);
        await ensureAudioContext();
        processFolder(e.target.files);
        e.target.value = null;
      });

      document.querySelector('.title-bar .minimize').addEventListener('click', () => {
        document.querySelector('.window').style.display = 'none';
      });
      document.querySelector('.title-bar .close').addEventListener('click', () => {
        document.querySelector('.window').style.display = 'none';
      });

      cancelButton.addEventListener('click', () => {
        processingCancelled = true;
        if (currentProcessing) currentProcessing.cancel();
        createdObjectURLs.forEach(url => {
          try {
            URL.revokeObjectURL(url);
          } catch (e) {}
        });
        createdObjectURLs = [];
        hideOverlay();
        updateStatus("Processing cancelled");
      });

      ['#select-file-button', '#select-folder-button', '.wave-button', '.wave-window', '#drop-zone'].forEach(selector => {
        document.querySelectorAll(selector).forEach(el => {
          el.addEventListener('click', activateAudio);
          el.addEventListener('touchstart', activateAudio);
        });
      });
    }

    async function ensureAudioContext() {
      if (!activeAudioContext) initAudioContext();
      if (activeAudioContext && activeAudioContext.state === 'suspended') {
        try {
          await activeAudioContext.resume();
          audioContextResumed = true;
          return true;
        } catch (e) {
          return false;
        }
      }
      return true;
    }

    function activateAudio() {
      if (!audioContextResumed && activeAudioContext) {
        try {
          if (activeAudioContext.state === 'suspended') {
            activeAudioContext.resume().then(() => {
              audioContextResumed = true;
            });
          }
        } catch (e) {}
      }
    }

    function initAudioContext() {
      if (!activeAudioContext) {
        try {
          const ContextClass = window.AudioContext || window.webkitAudioContext;
          activeAudioContext = new ContextClass();
          return activeAudioContext;
        } catch (e) {
          updateFileInfo(`<div class="file-error">AudioContext error: ${e.message}</div>`);
          return null;
        }
      }
      return activeAudioContext;
    }

    function checkMemoryAndWarn() {
      if (memoryWarningShown) return;
      if (navigator.deviceMemory && navigator.deviceMemory < 4) {
        document.getElementById('memory-warning').style.display = 'block';
        memoryWarningShown = true;
      }
    }

    function updateStatus(message) {
      const el = document.getElementById('status-bar');
      if (el) el.textContent = message;
    }

    function updateCurrentFile(message) {
      const el = document.getElementById('current-file');
      if (el) el.textContent = message;
    }

    function updateFileInfo(message) {
      const fileInfo = document.getElementById('file-info');
      if (!fileInfo) return;
      const div = document.createElement('div');
      div.innerHTML = message;
      fileInfo.appendChild(div);
      fileInfo.scrollTop = fileInfo.scrollHeight;
    }

    function showOverlay() {
      document.getElementById('overlay').style.display = 'block';
      document.getElementById('win95-loader').style.display = 'block';
      processingCancelled = false;
      lastProgress = 0;
    }

    function hideOverlay() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('win95-loader').style.display = 'none';
    }

    function handleDragOver(e) {
      e.preventDefault();
      dragCounter++;
      document.getElementById('drop-zone').classList.add('dragover');
    }

    function handleDragLeave() {
      dragCounter--;
      if (dragCounter <= 0) document.getElementById('drop-zone').classList.remove('dragover');
    }

    function handleDrop(e) {
      e.preventDefault();
      dragCounter = 0;
      document.getElementById('drop-zone').classList.remove('dragover');

      if (e.dataTransfer.items) {
        const items = [];
        for (const item of e.dataTransfer.items) {
          if (item.kind === 'file') {
            const file = item.getAsFile();
            if (file) items.push({ file, path: file.name });
          }
        }
        processItems(items);
      } else if (e.dataTransfer.files.length > 0) {
        const items = Array.from(e.dataTransfer.files).map(file => ({ file, path: file.name }));
        processItems(items);
      }
    }

    async function processFiles(files) {
      if (!files || files.length === 0) return;
      const items = Array.from(files).map(file => ({ file, path: file.name }));
      await processItems(items);
    }

    async function processFolder(files) {
      if (!files || files.length === 0) return;
      const items = [];
      for (const file of files) {
        const path = file.webkitRelativePath || file.name;
        items.push({ file, path });
      }
      await processItems(items);
    }

    async function processItems(items) {
      if (!items || items.length === 0) {
        updateStatus("No files to process");
        return;
      }
      
      // Sort files by size (smallest first)
      items.sort((a, b) => a.file.size - b.file.size);
      
      processingCancelled = false;
      const segmentContainer = document.getElementById('segment-container');
      const fileInfo = document.getElementById('file-info');
      const cancelButton = document.getElementById('cancel-button');
      showOverlay();
      fileInfo.innerHTML = '<div>Processing started...</div>';
      cancelButton.disabled = false;
      updateStatus(`Processing ${items.length} items`);
      const zip = new JSZip();
      let stereoOriginal = 0;
      let monoOriginal = 0;
      let totalOriginalSize = 0;
      let totalProcessedSize = 0;
      let processedFiles = 0;
      let totalTrimmed = 0;
      segmentContainer.innerHTML = '';
      const totalSegments = 50;
      for (let i = 0; i < totalSegments; i++) {
        const seg = document.createElement('div');
        seg.className = 'progress-segment';
        segmentContainer.appendChild(seg);
      }
      
      currentProcessing = { 
        cancel: () => { 
          processingCancelled = true; 
          cancelButton.disabled = true; 
          updateStatus("Processing cancelled"); 
        } 
      };
      
      try {
        const promises = [];
        
        for (let i = 0; i < items.length; i++) {
          if (processingCancelled) break;
          
          const item = items[i];
          const promise = processSingleItem(item, i, items.length, zip)
            .then(result => {
              if (!result) return;
              processedFiles++;
              totalOriginalSize += result.originalSize || 0;
              totalProcessedSize += result.processedSize || 0;
              totalTrimmed += result.trimmedSamples || 0;
              if (result.channels === 1) monoOriginal++;
              else if (result.channels === 2) stereoOriginal++;
            });
          
          promises.push(promise);
        }
        
        await Promise.all(promises);
        
        if (!processingCancelled && processedFiles > 0) {
          const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }, metadata => {
            updateStatus(`Compressing: ${metadata?.percent ? metadata.percent.toFixed(1) : 0}%`);
          });
          await updateProgressBar(1);
          const zipUrl = URL.createObjectURL(zipBlob);
          createdObjectURLs.push(zipUrl);
          const a = document.createElement('a');
          a.href = zipUrl;
          a.download = "ko2_processed_audio.zip";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => { try { URL.revokeObjectURL(zipUrl); } catch (e) {} createdObjectURLs = createdObjectURLs.filter(url => url !== zipUrl); }, 2000);
          const fidelity = getSelectedValue('fidelity');
          const channels = getSelectedValue('channels');
          fileInfo.innerHTML += `<div><b>Processed ${processedFiles} files</b></div><div>Original size: ${formatBytes(totalOriginalSize)}</div><div>Processed size: ${formatBytes(totalProcessedSize)}</div><div>Space saved: ${totalOriginalSize > 0 ? (100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1) : 0}%</div>`;
          if (document.getElementById('auto-trim').checked && totalTrimmed > 0) fileInfo.innerHTML += `<div>Total silence trimmed: ${(totalTrimmed / 44100).toFixed(2)}s</div>`;
          fileInfo.innerHTML += `<div>Fidelity: ${fidelity.toUpperCase()}</div><div>Channels: ${channels}</div><div>Stereo: ${stereoOriginal}, Mono: ${monoOriginal}</div>`;
          updateStatus(`Processed ${processedFiles} files. Space saved: ${totalOriginalSize > 0 ? (100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1) : 0}%`);
        }
      } catch (error) {
        if (!processingCancelled) {
          updateFileInfo(`<div class="file-error">Critical error: ${escapeHtml(error.message)}</div>`);
        }
      } finally {
        if (!processingCancelled) hideOverlay();
        currentProcessing = null;
      }
    }

    async function processSingleItem(item, index, total, zip) {
      try {
        updateCurrentFile(`Processing: ${item.path} (${index + 1}/${total})`);
        updateFileInfo(`Processing: ${escapeHtml(item.path)}`);
        
        if (!isSupportedAudioType(item.file.type, item.file.name)) {
          throw new Error(`Unsupported file type: ${item.file.type || item.file.name.split('.').pop()}`);
        }
        
        if (item.file.size > MAX_FILE_SIZE) {
          throw new Error(`File size exceeds limit (${(item.file.size / (1024 * 1024)).toFixed(1)}MB)`);
        }
        
        const fileExtension = (item.file.name.split('.').pop() || 'wav').toLowerCase();
        const pathParts = item.path.split('/');
        const origFilename = pathParts.pop();
        const safeFilename = origFilename.replace(/[^\w\.\-]/gi, '');
        const newFilename = safeFilename.replace(/\.[^/.]+$/, '') + '_ko2.' + fileExtension;
        const fileName = [...pathParts, newFilename].join('/');
        
        const result = await processWithWorker(item.file, item.path, index, total);
        
        if (!result) return null;
        
        const { processedBlob, originalSize, processedSize, channels, trimmedSamples } = result;
        zip.file(fileName, processedBlob);
        
        const originalSizeKB = (originalSize / 1024).toFixed(1);
        const processedSizeKB = (processedSize / 1024).toFixed(1);
        const sizeDifference = processedSize - originalSize;
        let sizeInfo = sizeDifference > 0 ? `INCREASED by ${(sizeDifference / 1024).toFixed(1)}KB` : `DECREASED by ${(-sizeDifference / 1024).toFixed(1)}KB`;
        updateFileInfo(`<div>Processed: ${escapeHtml(fileName)}</div><div>Original: ${originalSizeKB}KB → Processed: ${processedSizeKB}KB</div><div>${sizeInfo}</div>`);
        
        const url = URL.createObjectURL(processedBlob);
        createdObjectURLs.push(url);
        createWaveWindow(fileName, url, null);
        
        return { 
          fileName, 
          url, 
          originalSize, 
          processedSize, 
          trimmedSamples, 
          channels 
        };
      } catch (error) {
        if (!processingCancelled) handleProcessingError(error, item);
        return null;
      }
    }

    function updateProgressBar(task) {
      const { progress, index, total } = task;
      const baseProgress = index / total;
      const weightedProgress = baseProgress + (progress * (1 / total));
      
      const segments = document.querySelectorAll('.progress-segment');
      const segmentsToActivate = Math.floor(weightedProgress * segments.length);
      
      for (let i = 0; i < segments.length; i++) {
        const shouldBeActive = i < segmentsToActivate;
        const isActive = segments[i].classList.contains('active');
        
        if (shouldBeActive !== isActive) {
          segments[i].classList.toggle('active', shouldBeActive);
        }
      }
    }

    function isSupportedAudioType(mimeType, fileName) {
      const supportedTypes = ['audio/wav', 'audio/wave', 'audio/x-wav', 'audio/mpeg', 'audio/mp3', 'audio/ogg', 'audio/vorbis', 'audio/aac', 'audio/aacp', 'audio/flac', 'audio/x-flac'];
      const ext = fileName.split('.').pop().toLowerCase();
      const supportedExts = ['wav', 'mp3', 'ogg', 'aac', 'flac', 'm4a'];
      return supportedTypes.includes(mimeType) || supportedExts.includes(ext);
    }

    function getSelectedValue(name) {
      const group = document.querySelector(`.win95-list[data-group="${name}"]`);
      return group?.querySelector('.list-item.selected')?.dataset.value || 'cd';
    }

    function createWaveWindow(title, url, audioBuffer) {
      if (waveWindows.length >= MAX_PREVIEW_WINDOWS) {
        const oldestWindow = waveWindows.shift();
        if (oldestWindow && oldestWindow.element) {
          try {
            if (oldestWindow.element.wavesurfer) oldestWindow.element.wavesurfer.destroy();
            safeRevoke(oldestWindow.url);
            document.body.removeChild(oldestWindow.element);
          } catch (e) {}
        }
      }
      windowZIndex += 2;
      const top = 80 + (waveWindows.length * 30);
      const left = 100 + (waveWindows.length * 30);
      const windowElement = document.createElement('div');
      windowElement.className = 'wave-window window';
      windowElement.id = 'wave-window-' + Date.now();
      windowElement.style.zIndex = windowZIndex;
      windowElement.style.top = top + 'px';
      windowElement.style.left = left + 'px';
      windowElement.innerHTML = `
        <div class="title-bar">
          <span>${escapeHtml(title)}</span>
          <div class="window-controls">
            <button class="minimize" title="Minimize">_</button>
            <button class="close" title="Close">×</button>
          </div>
        </div>
        <div class="content">
          <div class="wave-container">
            <div class="wave-title">${escapeHtml(title)}</div>
            <div class="wave-element-container"><div class="wave-element"></div></div>
            <div class="preview-controls">
              <button class="wave-button play-button"><i class="fas fa-play"></i> Play</button>
              <button class="wave-button pause-button" style="display:none"><i class="fas fa-pause"></i> Pause</button>
              <button class="wave-button stop-button"><i class="fas fa-stop"></i> Stop</button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(windowElement);

      const minimizeBtn = windowElement.querySelector('.minimize');
      const closeBtn = windowElement.querySelector('.close');
      const playButton = windowElement.querySelector('.play-button');
      const pauseButton = windowElement.querySelector('.pause-button');
      const stopButton = windowElement.querySelector('.stop-button');
      const waveContainer = windowElement.querySelector('.wave-element');
      const titleBar = windowElement.querySelector('.title-bar');

      const minimizeWindow = () => {
        const content = windowElement.querySelector('.content');
        content.style.display = content.style.display === 'none' ? 'block' : 'none';
      };

      const closeWindow = () => {
        if (windowElement.wavesurfer) {
          try { windowElement.wavesurfer.destroy(); } catch (e) {}
        }
        safeRevoke(url);
        document.body.removeChild(windowElement);
        waveWindows = waveWindows.filter(w => w.id !== windowElement.id);
      };

      minimizeBtn.addEventListener('click', minimizeWindow);
      minimizeBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        minimizeWindow();
      });

      closeBtn.addEventListener('click', closeWindow);
      closeBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        closeWindow();
      });

      function startDrag(e) {
        e.preventDefault();
        windowZIndex += 2;
        windowElement.style.zIndex = windowZIndex;
        let pos3 = e.clientX || (e.touches && e.touches[0].clientX);
        let pos4 = e.clientY || (e.touches && e.touches[0].clientY);
        document.addEventListener('mousemove', dragMove);
        document.addEventListener('touchmove', dragMove, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);

        function dragMove(e) {
          e.preventDefault();
          const clientX = e.clientX || (e.touches && e.touches[0].clientX);
          const clientY = e.clientY || (e.touches && e.touches[0].clientY);
          if (!clientX || !clientY) return;
          windowElement.style.top = (parseInt(windowElement.style.top) + (clientY - pos4)) + 'px';
          windowElement.style.left = (parseInt(windowElement.style.left) + (clientX - pos3)) + 'px';
          pos3 = clientX;
          pos4 = clientY;
        }

        function endDrag() {
          document.removeEventListener('mousemove', dragMove);
          document.removeEventListener('touchmove', dragMove);
          document.removeEventListener('mouseup', endDrag);
          document.removeEventListener('touchend', endDrag);
        }
      }

      titleBar.addEventListener('mousedown', startDrag);
      titleBar.addEventListener('touchstart', startDrag, { passive: false });

      try {
        if (typeof WaveSurfer === 'undefined') {
          throw new Error('WaveSurfer not loaded');
        }
        
        const wavesurfer = WaveSurfer.create({
          container: waveContainer,
          height: 128,
          barWidth: 3,
          barGap: 2,
          barRadius: 1,
          cursorWidth: 1,
          cursorColor: 'transparent',
          normalize: true,
          progressColor: '#000080',
          waveColor: '#c0c0c0',
          fillParent: true,
          interact: false,
          backend: 'MediaElement'
        });
        windowElement.wavesurfer = wavesurfer;

        playButton.addEventListener('click', () => {
          activateAudio();
          try {
            wavesurfer.play();
            playButton.style.display = 'none';
            pauseButton.style.display = 'block';
            updateStatus("Playing audio");
          } catch (e) {}
        });

        pauseButton.addEventListener('click', () => {
          wavesurfer.pause();
          pauseButton.style.display = 'none';
          playButton.style.display = 'block';
          updateStatus("Playback paused");
        });

        stopButton.addEventListener('click', () => {
          wavesurfer.stop();
          pauseButton.style.display = 'none';
          playButton.style.display = 'block';
          updateStatus("Playback stopped");
        });

        wavesurfer.on('ready', () => {});
        wavesurfer.on('error', (err) => {
          waveContainer.innerHTML = '';
          const errDiv = document.createElement('div');
          errDiv.className = 'file-error';
          errDiv.textContent = `WaveSurfer error: ${err?.message || 'Failed to load audio'}`;
          const fb = document.createElement('div');
          fb.className = 'mobile-fallback';
          const audio = document.createElement('audio');
          audio.controls = true;
          audio.style.width = '100%';
          audio.src = url;
          fb.appendChild(audio);
          waveContainer.appendChild(errDiv);
          waveContainer.appendChild(fb);
          playButton.style.display = 'none';
          pauseButton.style.display = 'none';
        });

        wavesurfer.load(url);

      } catch (e) {
        waveContainer.innerHTML = '';
        const errDiv = document.createElement('div');
        errDiv.className = 'file-error';
        errDiv.textContent = `WaveSurfer error: ${e?.message || 'Preview unavailable'}`;
        const fb = document.createElement('div');
        fb.className = 'mobile-fallback';
        const audio = document.createElement('audio');
        audio.controls = true;
        audio.style.width = '100%';
        audio.src = url;
        fb.appendChild(audio);
        waveContainer.appendChild(errDiv);
        waveContainer.appendChild(fb);
        playButton.style.display = 'none';
        pauseButton.style.display = 'none';
      }

      const windowObj = {
        id: windowElement.id,
        element: windowElement,
        url: url
      };

      waveWindows.push(windowObj);
      return windowElement;
    }

    function handleProcessingError(error, item) {
      const errorMessage = error?.message || String(error);
      const fileName = item?.file?.name || 'unknown file';
      console.error(`Processing error for ${fileName}:`, error);
      document.getElementById('file-info').innerHTML += `
        <div class="file-error">
          <strong>Error processing:</strong> ${escapeHtml(fileName)}<br>
          ${escapeHtml(errorMessage)}
        </div>
      `;
      updateStatus(`Error: ${escapeHtml(errorMessage)} (${escapeHtml(fileName)})`);
      if (errorMessage.toLowerCase().includes('memory') || errorMessage.toLowerCase().includes('allocation')) {
        document.getElementById('memory-warning').style.display = 'block';
        memoryWarningShown = true;
      }
    }

    function escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    }

    function formatBytes(bytes) {
      if (!bytes) return '0 B';
      if (bytes < 1024) return bytes + ' B';
      else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      else return (bytes / 1048576).toFixed(1) + ' MB';
    }

    function safeRevoke(url) {
      try {
        URL.revokeObjectURL(url);
        createdObjectURLs = createdObjectURLs.filter(u => u !== url);
      } catch (e) {}
    }

    function isMobile() {
      return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
    }

    window.addEventListener('beforeunload', () => {
      createdObjectURLs.forEach(url => {
        try { URL.revokeObjectURL(url); } catch (e) {}
      });
      if (activeAudioContext) { try { activeAudioContext.close(); } catch (e) {} }
    });
  </script>
</body>
</html>