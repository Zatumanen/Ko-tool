<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KO II Audio Tool v1.63</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* ... (стили остаются без изменений) ... */
    .render-notice {
      color: #444;
      font-size: 13px;
      padding: 10px;
      background: #e6f7ff;
      border: 1px solid #99ccff;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="window">
    <div class="title-bar">
      <span>KO II Audio Tool — v1.63</span>
      <div>
        <button class="minimize">-</button>
        <button class="close">X</button>
      </div>
    </div>
    <div class="content">
      <!-- ... (остальной интерфейс без изменений) ... -->
      
      <div class="drop-zone" id="drop-zone">
        <input type="file" id="audio-upload" accept=".mp3,.wav,.ogg,audio/*" multiple />
        <span>DRAG AND DROP OR SELECT AUDIO FILES</span>
        <div id="file-info"></div>
      </div>
      
      <div id="waveform-list" style="margin-top: 10px;"></div>
      
      <!-- Добавлена опция пропуска рендеринга -->
      <div style="margin-top: 12px; display: flex; align-items: center;">
        <input type="checkbox" id="skip-render" style="margin-right: 8px;">
        <label for="skip-render">Skip waveform rendering for large batches</label>
      </div>
      
      <button id="select-file-button">Select Audio Files</button>
    </div>
  </div>

  <!-- ... (остальной HTML без изменений) ... -->

  <script>
    // Глобальные переменные
    const waveformQueue = [];
    let waveformBusy = false;
    let activeAudioContext = null;
    let createdObjectURLs = [];
    const MAX_FILES = 50; // Увеличено ограничение файлов

    // Проверка загрузки Wavesurfer.js
    function waitForWavesurfer() {
      return new Promise(resolve => {
        if (window.WaveSurfer) {
          resolve();
          return;
        }

        const checkInterval = setInterval(() => {
          if (window.WaveSurfer) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
      });
    }

    // Инициализация приложения после загрузки библиотек
    document.addEventListener('DOMContentLoaded', async () => {
      // Ждем загрузки Wavesurfer
      await waitForWavesurfer();
      initApp();
    });

    function initApp() {
      // ... (инициализация без изменений) ...

      // Добавлен обработчик для кнопок закрытия
      document.querySelector('.close').addEventListener('click', () => {
        if (confirm('Close the application?')) {
          window.close();
        }
      });
    }

    // ... (функции обновления интерфейса без изменений) ...

    // Обработка файлов
    async function processFiles(files) {
      // Проверка количества файлов
      if (files.length > MAX_FILES) {
        const fileInfo = document.getElementById('file-info');
        fileInfo.innerHTML = `<div style="color:red">Warning: Processing ${files.length} files (max ${MAX_FILES} recommended)</div>`;
      }

      const overlay = document.getElementById('overlay');
      const loader = document.getElementById('win95-loader');
      const segmentContainer = document.getElementById('segment-container');
      const fileInfo = document.getElementById('file-info');
      const skipRender = document.getElementById('skip-render').checked;

      // Подготовка интерфейса
      overlay.style.display = 'block';
      loader.style.display = 'block';
      fileInfo.innerHTML = '';
      segmentContainer.innerHTML = '';
      document.getElementById('waveform-list').innerHTML = '';

      // Очистка предыдущих волн
      document.querySelectorAll('.wave-container').forEach(el => {
        if (el.wavesurfer) {
          el.wavesurfer.destroy();
        }
        el.remove();
      });

      // Создание контекста
      activeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Подготовка ZIP
      const zip = new JSZip();
      let processedCount = 0;
      let errors = 0;

      // Прогресс бар
      const totalSegments = 50;
      for (let i = 0; i < totalSegments; i++) {
        const seg = document.createElement('div');
        seg.className = 'progress-segment';
        segmentContainer.appendChild(seg);
      }

      // Обработка каждого файла
      for (let i = 0; i < files.length; i++) {
        // Обновление прогресса
        segmentContainer.querySelectorAll('.progress-segment').forEach((seg, idx) => {
          seg.classList.toggle('active', idx <= (i / files.length) * totalSegments);
        });

        try {
          const file = files[i];
          
          // Декодирование аудио
          const arrayBuffer = await file.arrayBuffer();
          const decoded = await activeAudioContext.decodeAudioData(arrayBuffer);
          
          // Получение настроек
          const fidelity = getSelectedValue('fidelity');
          const channels = getSelectedValue('channels');
          
          // Обработка аудио
          const converted = await convertChannels(decoded, channels);
          const downsampleRate = getDownsampleRate(fidelity, converted.sampleRate);
          const processed = await applySpeedAndFidelity(converted, 2.0, downsampleRate);
          
          // Генерация WAV
          const ko2Buffer = getKO2Buffer();
          const wavBlob = audioBufferToWav(processed, ko2Buffer);
          
          // Добавление в ZIP
          const fileName = file.name.replace(/\.[^/.]+$/, '') + '_ko2.wav';
          zip.file(fileName, wavBlob);
          
          // Визуализация (пропускаем если выбрана опция)
          if (!skipRender) {
            enqueueWaveformRender(wavBlob, fileName);
          }
          
          processedCount++;
          
        } catch (error) {
          console.error('Error processing file:', error);
          fileInfo.innerHTML += `<div style="color:red">Error with ${files[i].name}: ${error.message}</div>`;
          errors++;
        }
      }

      // Завершение прогресс бара
      segmentContainer.querySelectorAll('.progress-segment').forEach(seg => {
        seg.classList.add('active');
      });

      // Скачивание ZIP
      try {
        const zipBlob = await zip.generateAsync({ type: "blob" });
        const zipUrl = URL.createObjectURL(zipBlob);
        createdObjectURLs.push(zipUrl);
        
        const a = document.createElement('a');
        a.href = zipUrl;
        a.download = "ko2_processed_audio.zip";
        a.click();
        
        // Статистика
        fileInfo.innerHTML += `
          <div><b>Processed ${processedCount}/${files.length} files</b></div>
          <div>Errors: ${errors}</div>
        `;
        
        if (skipRender) {
          fileInfo.innerHTML += `<div class="render-notice">Waveform rendering skipped for performance</div>`;
        }

      } catch (error) {
        console.error('ZIP creation failed:', error);
        fileInfo.innerHTML += `<div style="color:red">ZIP creation failed: ${error.message}</div>`;
      }

      // Закрытие оверлея
      if (skipRender) {
        overlay.style.display = 'none';
        loader.style.display = 'none';
      } else {
        waitForRenderCompletion().then(() => {
          overlay.style.display = 'none';
          loader.style.display = 'none';
        });
      }
      
      // Очистка аудиоконтекста
      if (activeAudioContext) {
        activeAudioContext.close();
        activeAudioContext = null;
      }
    }

    // ... (функции аудио обработки без изменений) ...

    // Визуализация волны (с улучшенной обработкой ошибок)
    function renderWaveform(blob, filename) {
      return new Promise((resolve) => {
        // Проверка валидности данных
        if (!blob || blob.size < 500) {
          console.warn('Skipping invalid blob:', filename);
          return resolve();
        }

        // Создание контейнера
        const container = document.createElement('div');
        container.className = 'wave-container';
        
        // Заголовок
        const title = document.createElement('div');
        title.className = 'wave-title';
        title.textContent = filename.length > 50 ? filename.substring(0, 50) + '...' : filename;
        title.title = filename;
        
        // Контейнер волны
        const wave = document.createElement('div');
        wave.className = 'wave-element';
        
        // Кнопка воспроизведения
        const button = document.createElement('button');
        button.className = 'wave-button';
        button.innerHTML = '<i class="fas fa-play"></i> Play';
        
        // Добавление элементов
        container.appendChild(title);
        container.appendChild(wave);
        container.appendChild(button);
        document.getElementById('waveform-list').appendChild(container);
        
        let wavesurferReady = false;
        const renderTimeout = setTimeout(() => {
          if (!wavesurferReady) {
            wave.innerHTML = '<div class="render-notice">Render skipped: Timeout</div>';
            resolve();
          }
        }, 30000); // 30 секунд таймаут
        
        try {
          // Инициализация Wavesurfer
          const wavesurfer = WaveSurfer.create({
            container: wave,
            waveColor: '#000',
            progressColor: '#000080',
            height: 64,
            barWidth: 1.4,
            minPxPerSec: 50, // Уменьшено для производительности
            cursorColor: '#ff0000',
            renderFunction: (channels, ctx) => {
              // Упрощенная функция рендеринга
              const { width, height } = ctx.canvas;
              ctx.clearRect(0, 0, width, height);
              
              for (let i = 0; i < channels.length; i++) {
                const channel = channels[i];
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                
                for (let i = 0; i < width; i++) {
                  const index = Math.floor(i * channel.length / width);
                  const value = channel[index] * height / 2;
                  
                  ctx.lineTo(i, height / 2 + value);
                }
                
                ctx.strokeStyle = i === 0 ? '#000' : '#555';
                ctx.lineWidth = 1;
                ctx.stroke();
              }
            }
          });

          // Обработка готовности
          wavesurfer.on('ready', () => {
            clearTimeout(renderTimeout);
            wavesurferReady = true;
            button.addEventListener('click', () => {
              if (wavesurfer.isPlaying()) {
                wavesurfer.pause();
                button.innerHTML = '<i class="fas fa-play"></i> Play';
              } else {
                wavesurfer.play();
                button.innerHTML = '<i class="fas fa-pause"></i> Pause';
              }
            });
            resolve();
          });

          // Обработка ошибок
          wavesurfer.on('error', (err) => {
            clearTimeout(renderTimeout);
            wavesurferReady = true;
            console.error('Wavesurfer error:', err);
            wave.innerHTML = '<div class="render-notice">Render skipped: ' + err.message + '</div>';
            resolve();
          });

          // Загрузка
          wavesurfer.loadBlob(blob).catch(err => {
            console.error('Load error:', err);
            wave.innerHTML = '<div class="render-notice">Load failed</div>';
            resolve();
          });
          
          // Сохраняем ссылку для очистки
          container.wavesurfer = wavesurfer;

        } catch (err) {
          clearTimeout(renderTimeout);
          console.error('Wavesurfer init error:', err);
          wave.innerHTML = '<div class="render-notice">Init failed</div>';
          resolve();
        }
      });
    }

    // Управление очередью рендеринга (с увеличенной задержкой)
    function enqueueWaveformRender(blob, filename) {
      waveformQueue.push({ blob, filename });
      if (!waveformBusy) {
        processNextWaveform();
      }
    }

    async function processNextWaveform() {
      if (waveformQueue.length === 0) {
        waveformBusy = false;
        return;
      }

      waveformBusy = true;
      const { blob, filename } = waveformQueue.shift();
      
      try {
        // Увеличена задержка между рендерингом
        await new Promise(resolve => setTimeout(resolve, 1000));
        await renderWaveform(blob, filename);
      } catch (err) {
        console.error('Waveform render error:', err);
      }
      
      // Обработка следующего элемента
      setTimeout(processNextWaveform, 100);
    }

    // ... (вспомогательные функции без изменений) ...

    // Очистка при закрытии (улучшенная)
    window.addEventListener('beforeunload', () => {
      // Очистка Wavesurfer
      document.querySelectorAll('.wave-container').forEach(container => {
        if (container.wavesurfer) {
          try {
            container.wavesurfer.destroy();
          } catch (e) {
            console.warn('Error destroying wavesurfer:', e);
          }
        }
      });
      
      // Очистка Object URLs
      createdObjectURLs.forEach(url => {
        try {
          URL.revokeObjectURL(url);
        } catch (e) {
          console.warn('Error revoking URL:', e);
        }
      });
      createdObjectURLs = [];
      
      // Закрытие аудиоконтекста
      if (activeAudioContext) {
        try {
          activeAudioContext.close();
        } catch (e) {
          console.warn('Error closing audio context:', e);
        }
        activeAudioContext = null;
      }
    });
  </script>
</body>
</html>