<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>SpeedUpperCut</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
:root{--glow:#ff3333;--blue:#000080;--gray:#c0c0c0;--light:#fff;--dark:#808080}
body{margin:0;padding:20px;background:#008080;font-family:'Courier New',monospace;display:flex;justify-content:center;align-items:flex-start;min-height:100vh;overflow-x:hidden;background-image:radial-gradient(circle at 1px 1px,var(--dark) 1px,transparent 0),radial-gradient(circle at 1px 1px,var(--dark) 1px,transparent 0);background-size:4px 4px;background-position:0 0,2px 2px;touch-action:manipulation;-webkit-tap-highlight-color:transparent}
.desktop-icon{position:absolute;top:20px;left:30px;width:80px;text-align:center;color:white;text-shadow:1px 1px 1px black;cursor:pointer;user-select:none}.desktop-icon:hover{background:rgba(255,255,255,.2);transform:scale(1.05)}
.window{width:100%;max-width:480px;background:var(--gray);border:2px solid;border-top-color:var(--light);border-left-color:var(--light);border-right-color:var(--dark);border-bottom-color:var(--dark);box-shadow:2px 2px 4px rgba(0,0,0,.5);padding:0;position:relative;z-index:100}
.title-bar{background:var(--blue);color:#fff;padding:4px 8px;font-size:14px;display:flex;justify-content:space-between;align-items:center;border-bottom:2px solid var(--gray);cursor:move;user-select:none}
.title-bar button{width:20px;height:20px;border:none;background:var(--gray);cursor:pointer;border:1px outset;margin-left:4px;font-weight:bold}.title-bar button:active{border-style:inset}
.content{padding:12px;font-size:14px;color:#000}
.drop-zone{border:2px dashed #000;padding:20px;text-align:center;background:rgba(255,255,255,.3);position:relative;cursor:pointer;border-style:dotted}.drop-zone.dragover{background:rgba(0,128,0,.3)}.drop-zone input{position:absolute;inset:0;width:100%;height:100%;opacity:0;cursor:pointer}
.win95-list{border:2px inset var(--dark);background:#fff;height:100px;overflow-y:auto;font-size:13px}.list-item{padding:6px;cursor:pointer}.list-item:hover,.list-item.selected{background:var(--blue);color:#fff}
.progress-bar-container{background:#fff;border:2px inset var(--dark);height:24px;display:flex;gap:1px;padding:2px}.progress-segment{width:8px;background:var(--gray)}.progress-segment.active{background:var(--blue)}
.wave-window{position:absolute;width:500px;background:var(--gray);border:2px solid;border-top-color:var(--light);border-left-color:var(--light);border-right-color:var(--dark);border-bottom-color:var(--dark);box-shadow:2px 2px 4px rgba(0,0,0,.5);z-index:101;top:100px;left:100px}
.wave-element-container{width:100%;height:150px;background:#000}
.wave-button{padding:8px;background:var(--gray);border:2px outset;cursor:pointer;min-width:80px}
#overlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,.4);z-index:1000}#win95-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:320px;background:var(--gray);border:2px outset;padding:12px;font-family:'Courier New',monospace;font-size:14px}
.taskbar{position:fixed;bottom:0;left:0;right:0;background:var(--gray);height:36px;border-top:2px solid var(--light);display:flex;align-items:center;padding:0 8px;z-index:90}.start-button{padding:4px 8px;background:var(--gray);border:2px outset;font-weight:bold;cursor:pointer}.status-bar{margin-left:auto}
@media(max-width:768px){.window{width:95vw}.wave-window{width:90vw;left:5vw}.wave-element-container{height:100px!important}}
</style>
</head>
<body>
<div class="desktop-icon" onclick="document.querySelector('.window').style.display='block'"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4Ij48cmVjdCB4PSIyNCIgeT0iNDAiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0iI2U1MzkzNSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PHJlY3QgeD0iMjYiIHk9IjQ0IiB3aWR0aD0iMTIiIGhlaWdodD0iNCIgZmlsbD0iI2I3MWMxYyIvPjxwb2x5Z29uIHBvaW50cz0iMzIsMzIgMjgsMjggMzAsMjQgMzQsMjYgMzYsMjIgMzgsMzAiIGZpbGw9Im9yYW5nZSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxIi8+PC9zdmc+" width="48" height="48"><div>KO II Tool</div></div>

<div class="window">
  <div class="title-bar">
    <span>SpeedUpperCut</span>
    <div class="window-controls">
      <button onclick="document.querySelector('.window').style.display='none'">×</button>
    </div>
  </div>
  <div class="content">
    <div class="memory-warning" id="memory-warning" style="display:none"><i class="fas fa-exclamation-triangle"></i>Large files may use lots of memory</div>
    <div class="mobile-warning" id="mobile-warning" style="display:none"><i class="fas fa-mobile-alt"></i>Mobile may be slow</div>
    <div style="display:flex;gap:8px;margin-bottom:10px">
      <div class="win95-inset" style="flex:1"><label>FIDELITY</label><br><div class="win95-list" data-group="fidelity"><div data-value="cd" class="list-item selected">CD (16-bit, 44.1kHz)</div><div data-value="sp8" class="list-item">SP-1200 (8-bit, 22kHz)</div><div data-value="sp16" class="list-item">SP-1200 (16-bit, 22kHz)</div><div data-value="sk" class="list-item">SK-1 (8-bit, 9kHz)</div></div></div>
      <div class="win95-inset" style="flex:1"><label>CHANNELS</label><br><div class="win95-list" data-group="channels"><div data-value="stereo" class="list-item selected">Stereo</div><div data-value="mono" class="list-item">Mono</div></div></div>
    </div>
    <div class="trim-control"><input type="checkbox" id="auto-trim" checked><label for="auto-trim">Auto-trim silence</label></div>
    <div class="drop-zone" id="drop-zone">
      <i class="fas fa-cloud-upload-alt" style="font-size:36px"></i>
      <input type="file" id="audio-upload" accept=".wav,.mp3,.aac,.ogg,.flac,audio/*" multiple>
      <input type="file" id="folder-upload" webkitdirectory directory multiple style="display:none">
      <span>DRAG AND DROP OR SELECT FILES/FOLDERS</span>
    </div>
    <div class="button-group"><button onclick="document.getElementById('audio-upload').click()">Select Files</button><button onclick="document.getElementById('folder-upload').click()">Select Folder</button><button onclick="document.getElementById('file-info').innerHTML=''">Clear List</button></div>
    <div id="file-info">
      <div>Drop or select audio files/folders to process</div>
      <div>Files will be sped up 2× to save space</div>
      <div>Auto-trim removes silence at start/end</div>
      <div>Folder structure will be preserved in output</div>
      <div>Files will be saved in their original format</div>
    </div>
  </div>
</div>

<div id="overlay">
  <div id="win95-loader">
    <div id="processing-title">Processing Audio Files...</div>
    <div class="progress-bar-container" id="segment-container"></div>
    <div id="current-file">Preparing...</div>
    <button id="cancel-button" onclick="processingCancelled=true">Cancel</button>
  </div>
</div>

<div class="taskbar">
  <div class="start-button"><i class="fas fa-bars"></i> Start</div>
  <div class="status-bar" id="status-bar">Ready</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://unpkg.com/wavesurfer.js@7"></script>
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
<script>
// ========== CORE STATE ==========
let activeAudioContext = null, createdObjectURLs = [], dragCounter = 0, processingCancelled = false;
const MAX_PREVIEW = 5, MAX_FILE = 50 * 1024 * 1024, BATCH = 3;

// ========== UTILS ==========
function escapeHtml(t) { return t ? t.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : ''; }
function formatBytes(t) { return t ? (t < 1024 ? t + ' B' : t < 1048576 ? (t / 1024).toFixed(1) + ' KB' : (t / 1048576).toFixed(1) + ' MB') : '0 B'; }
function safeRevoke(url) { try { URL.revokeObjectURL(url); } catch {} }
function getSelected(name) { return document.querySelector(`.win95-list[data-group="${name}"] .selected`)?.dataset.value || 'cd'; }
function getFidelitySet(v) { switch (v) { case 'sp8': return { sr: 22050, bd: 8 }; case 'sk': return { sr: 9000, bd: 8 }; default: return { sr: 44100, bd: 16 }; } }

// ========== AUDIO ==========
async function ensureContext() {
  if (!activeAudioContext) activeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
  if (activeAudioContext.state === 'suspended') await activeAudioContext.resume();
  return activeAudioContext;
}

// ========== TRIM ==========
function trimSilence(buf, thresholdDb = -60, minDur = 0.1) {
  const t = Math.pow(10, thresholdDb / 20), sr = buf.sampleRate, min = Math.floor(minDur * sr);
  const ch = buf.numberOfChannels, len = buf.length, blk = 1024;
  let s = 0, e = len - 1;
  for (let i = 0; i < len; i += blk) {
    const end = Math.min(i + blk, len); let ok = false;
    for (let c = 0; c < ch; c++) {
      const d = buf.getChannelData(c);
      for (let j = i; j < end; j++) if (Math.abs(d[j]) > t) { ok = true; break; }
      if (ok) break;
    }
    if (ok) { s = Math.max(0, i - blk); break; }
  }
  for (let i = len - blk; i >= 0; i -= blk) {
    const end = Math.min(i + blk, len); let ok = false;
    for (let c = 0; c < ch; c++) {
      const d = buf.getChannelData(c);
      for (let j = i; j < end; j++) if (Math.abs(d[j]) > t) { ok = true; break; }
      if (ok) break;
    }
    if (ok) { e = Math.min(len - 1, i + blk); break; }
  }
  if (s >= e) return buf;
  const newLen = e - s + 1;
  const out = new AudioBuffer({ length: newLen, sampleRate: sr, numberOfChannels: ch });
  for (let c = 0; c < ch; c++) out.copyToChannel(buf.getChannelData(c).subarray(s, e + 1), c);
  return out;
}

// ========== ENCODE ==========
function writeString(view, offset, str) { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); }
function audioBufferToWav(buf) {
  const fset = getFidelitySet(getSelected("fidelity")), sr = fset.sr, bd = fset.bd, ch = buf.numberOfChannels;
  const bytes = bd / 8, dataLen = buf.length * ch * bytes;
  const riff = new ArrayBuffer(44 + dataLen), v = new DataView(riff);
  writeString(v, 0, "RIFF"); v.setUint32(4, 36 + dataLen, true); writeString(v, 8, "WAVE");
  writeString(v, 12, "fmt "); v.setUint32(16, 16, true); v.setUint16(20, 1, true); v.setUint16(22, ch, true);
  v.setUint32(24, sr, true); v.setUint32(28, sr * ch * bytes, true); v.setUint16(32, ch * bytes, true); v.setUint16(34, bd, true);
  writeString(v, 36, "data"); v.setUint32(40, dataLen, true);
  let data;
  if (bd === 8) { data = new Uint8Array(dataLen); let idx = 44; for (let i = 0; i < buf.length; i++) for (let c = 0; c < ch; c++) { const val = buf.getChannelData(c)[i]; data[idx++] = Math.max(0, Math.min(255, Math.round((val + 1) * 127.5))); } }
  else { data = new Int16Array(dataLen / 2); let idx = 0; for (let i = 0; i < buf.length; i++) for (let c = 0; c < ch; c++) { const val = buf.getChannelData(c)[i]; data[idx++] = val < 0 ? Math.round(val * 32768) : Math.round(val * 32767); } }
  return new Blob([riff, data], { type: "audio/wav" });
}

// ========== MP3 ==========
class Mp3Encoder {
  constructor(ch, sr, kb) {
    if (typeof lamejs === 'undefined') throw new Error('LameJS not loaded');
    this.lame = new lamejs.Mp3Encoder(ch, sr, kb);
  }
  encode(buf) {
    const ch = buf.numberOfChannels, len = buf.length;
    const left = buf.getChannelData(0), right = ch > 1 ? buf.getChannelData(1) : left;
    const block = 1152, l16 = new Int16Array(block), r16 = ch > 1 ? new Int16Array(block) : l16;
    const mp3 = [];
    for (let i = 0; i < len; i += block) {
      const lChunk = left.subarray(i, i + block), rChunk = right.subarray(i, i + block);
      for (let j = 0; j < lChunk.length; j++) {
        l16[j] = lChunk[j] < 0 ? Math.round(lChunk[j] * 32768) : Math.round(lChunk[j] * 32767);
        if (ch > 1) r16[j] = rChunk[j] < 0 ? Math.round(rChunk[j] * 32768) : Math.round(rChunk[j] * 32767);
      }
      const buf = this.lame.encodeBuffer(l16.subarray(0, lChunk.length), ch > 1 ? r16.subarray(0, lChunk.length) : undefined);
      if (buf.length) mp3.push(new Int8Array(buf));
    }
    const last = this.lame.flush();
    if (last.length) mp3.push(new Int8Array(last));
    return new Blob(mp3, { type: "audio/mp3" });
  }
}

// ========== PROCESSING ==========
async function processFiles(files) {
  const items = Array.from(files).map(f => ({ file: f, path: f.webkitRelativePath || f.name }));
  await processItems(items);
}
async function processItems(items) {
  if (!items.length) return;
  showOverlay(); processingCancelled = false;
  const zip = new JSZip();
  const segs = document.getElementById('segment-container');
  segs.innerHTML = '';
  for (let i = 0; i < 50; i++) { const seg = document.createElement('div'); seg.className = 'progress-segment'; segs.appendChild(seg); }
  const segArr = [...segs.children];
  let totalOriginal = 0, totalProcessed = 0, processed = 0;
  for (const [idx, item] of items.entries()) {
    if (processingCancelled) break;
    const file = item.file;
    try {
      updateCurrentFile(`${item.path} (${idx + 1}/${items.length})`);
      if (!isSupportedAudioType(file.type, file.name)) throw new Error('Unsupported format');
      if (file.size > MAX_FILE) throw new Error('File too large');
      await ensureAudioContext();
      const ab = await file.arrayBuffer();
      const audio = await activeAudioContext.decodeAudioData(ab.slice(0));
      let buf = await convertChannels(audio, getSelected("channels"));
      buf = await applySpeedAndFidelity(buf, 2, getFidelitySet(getSelected("fidelity")).sr);
      if (document.getElementById("auto-trim").checked) buf = trimSilence(buf);
      const ext = (file.name.split('.').pop() || 'wav').toLowerCase();
      let blob;
      if (ext === 'mp3') blob = new Mp3Encoder(buf.numberOfChannels, buf.sampleRate, 192).encode(buf);
      else blob = audioBufferToWav(buf);
      const newName = item.path.replace(/\.[^/.]+$/, '') + '_ko2.' + ext;
      zip.file(newName, blob);
      const url = URL.createObjectURL(blob);
      createdObjectURLs.push(url);
      createWaveWindow(newName, url, buf);
      totalOriginal += file.size; totalProcessed += blob.size; processed++;
      segArr.forEach((s, i) => s.classList.toggle('active', i < processed / items.length * 50));
    } catch (e) { updateFileInfo(`<div class="file-error">${item.path}: ${e.message}</div>`, true); }
  }
  if (processed) {
    const zipBlob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
    const zipUrl = URL.createObjectURL(zipBlob);
    createdObjectURLs.push(zipUrl);
    const a = document.createElement('a'); a.href = zipUrl; a.download = 'ko2_processed_audio.zip'; a.click();
    updateFileInfo(`<div><b>Processed ${processed} files</b></div><div>Original: ${formatBytes(totalOriginal)}</div><div>Processed: ${formatBytes(totalProcessed)}</div><div>Saved ${(100 - (totalProcessed / totalOriginal * 100)).toFixed(1)} %</div>`, true);
  }
  hideOverlay();
}
function createWaveWindow(title, url, buf, opts) {
  if (waveWindows.length >= MAX_PREVIEW_WINDOWS) { const old = waveWindows.shift(); old.element.remove(); safeRevoke(old.url); }
  windowZIndex += 2;
  const win = document.createElement('div'); win.className = 'wave-window'; win.style.zIndex = windowZIndex; win.style.top = 80 + 30 * waveWindows.length + 'px'; win.style.left = 100 + 30 * waveWindows.length + 'px';
  win.innerHTML = `<div class="title-bar"><span>${escapeHtml(title)}</span><button onclick="this.closest('.wave-window').remove()">×</button></div>
    <div class="content"><div class="wave-container"><div class="wave-title">${escapeHtml(title)}</div><div class="wave-element-container"><div class="wave-element"></div></div><div class="preview-controls"><button class="wave-button play"><i class="fas fa-play"></i></button><button class="wave-button pause" style="display:none"><i class="fas fa-pause"></i></button><button class="wave-button stop"><i class="fas fa-stop"></i></button></div></div></div>`;
  document.body.appendChild(win);
  const Wave = window.WaveSurfer?.default || window.WaveSurfer;
  const surfer = Wave.create({ container: win.querySelector('.wave-element'), height: 128, backend: 'MediaElement' });
  surfer.load(url);
  win.querySelector('.play').onclick = () => surfer.play();
  win.querySelector('.pause').onclick = () => surfer.pause();
  win.querySelector('.stop').onclick = () => surfer.stop();
  makeDraggable(win);
  waveWindows.push({ element: win, url });
}
function makeDraggable(el) {
  let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  el.querySelector('.title-bar').addEventListener('pointerdown', e => {
    e.preventDefault(); windowZIndex += 2; el.style.zIndex = windowZIndex;
    pos3 = e.clientX; pos4 = e.clientY; document.addEventListener('pointermove', move); document.addEventListener('pointerup', up);
    function move(e) { pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; el.style.top = el.offsetTop - pos2 + 'px'; el.style.left = el.offsetLeft - pos1 + 'px'; }
    function up() { document.removeEventListener('pointermove', move); document.removeEventListener('pointerup', up); }
  });
}

// ========== INIT ==========
document.addEventListener('DOMContentLoaded', () => {
  if (navigator.deviceMemory && navigator.deviceMemory < 4) document.getElementById('memory-warning').style.display = 'block';
  document.querySelectorAll('.win95-list').forEach(list => list.addEventListener('click', e => {
    if (e.target.classList.contains('list-item')) {
      list.querySelectorAll('.list-item').forEach(i => i.classList.remove('selected'));
      e.target.classList.add('selected');
    }
  }));
  document.getElementById('audio-upload').addEventListener('change', e => processFiles(e.target.files));
  document.getElementById('folder-upload').addEventListener('change', e => processFiles(e.target.files));
  document.getElementById('drop-zone').addEventListener('dragover', e => { e.preventDefault(); e.currentTarget.classList.add('dragover'); });
  document.getElementById('drop-zone').addEventListener('dragleave', () => document.getElementById('drop-zone').classList.remove('dragover'));
  document.getElementById('drop-zone').addEventListener('drop', e => { e.preventDefault(); document.getElementById('drop-zone').classList.remove('dragover'); const items = [...e.dataTransfer.files].map(f => ({ file: f, path: f.webkitRelativePath || f.name })); processItems(items); });
});
</script>
</body>
</html>
