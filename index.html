<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KO II Audio Tool v2.0.5</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Стили без изменений */
  </style>
</head>
<body>
  <div class="window">
    <div class="title-bar">
      <span>KO II Audio Tool — v2.0.6</span>
      <div>
        <button class="minimize">-</button>
        <button class="close">X</button>
      </div>
    </div>
    <div class="content">
      <!-- Интерфейс без изменений -->
    </div>
  </div>

  <div id="overlay">
    <div id="win95-loader">
      <div>Processing Audio Files...</div>
      <div class="progress-bar-container" id="segment-container"></div>
    </div>
  </div>

  <!-- Исправление версии Wavesurfer -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/wavesurfer.js@7.6.0/dist/wavesurfer.js"></script>

  <script>
    // Глобальные переменные
    const waveformQueue = [];
    let waveformBusy = false;
    let activeAudioContext = null;
    let isProcessingCancelled = false;

    // Инициализация приложения
    document.addEventListener('DOMContentLoaded', async () => {
      initApp();
    });

    function initApp() {
      // Обновление слайдеров
      updateSliderValue('pitch');
      updateSliderValue('release');
      
      // Назначение обработчиков событий
      document.getElementById('pitch-slider').addEventListener('input', () => updateSliderValue('pitch'));
      document.getElementById('release-slider').addEventListener('input', () => updateSliderValue('release'));

      // Обработка списков
      document.querySelectorAll('.win95-list').forEach(group => {
        group.addEventListener('click', e => {
          if (e.target.classList.contains('list-item')) {
            group.querySelectorAll('.list-item').forEach(item => {
              item.classList.remove('selected');
            });
            e.target.classList.add('selected');
          }
        });
      });

      // Элементы интерфейса
      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('audio-upload');
      const selectButton = document.getElementById('select-file-button');

      // Drag and drop
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleDrop);
      selectButton.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', handleFileSelect);

      // Добавляем обработчик отмены операции
      document.querySelector('.close').addEventListener('click', () => {
        if (isProcessingCancelled) return;
        isProcessingCancelled = true;
        if (activeAudioContext) {
          activeAudioContext.close().catch(() => {});
          activeAudioContext = null;
        }
        document.getElementById('overlay').style.display = 'none';
      });
    }

    // Функции обновления интерфейса
    function updateSliderValue(type) {
      const slider = document.getElementById(`${type}-slider`);
      const valueSpan = document.getElementById(`${type}-value`);
      if (slider && valueSpan) {
        valueSpan.textContent = slider.value;
      }
    }

    // Drag and drop обработчики
    function handleDragOver(e) {
      e.preventDefault();
      document.getElementById('drop-zone').classList.add('dragover');
    }

    function handleDragLeave() {
      document.getElementById('drop-zone').classList.remove('dragover');
    }

    function handleDrop(e) {
      e.preventDefault();
      document.getElementById('drop-zone').classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) {
        processFiles(e.dataTransfer.files);
      }
    }

    function handleFileSelect() {
      if (this.files.length) processFiles(this.files);
    }

    // Обработка файлов (исправленная версия)
    async function processFiles(files) {
      const overlay = document.getElementById('overlay');
      const loader = document.getElementById('win95-loader');
      const segmentContainer = document.getElementById('segment-container');
      const fileInfo = document.getElementById('file-info');

      // Сброс состояния
      overlay.style.display = 'block';
      loader.style.display = 'block';
      fileInfo.innerHTML = '';
      segmentContainer.innerHTML = '';
      document.getElementById('waveform-list').innerHTML = '';
      isProcessingCancelled = false;

      // Создание контекста
      activeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Подготовка ZIP
      const zip = new JSZip();
      let stereoOriginal = 0;
      let monoOriginal = 0;
      let totalOriginalSize = 0;
      let totalProcessedSize = 0;

      // Прогресс бар
      const totalSegments = 50;
      for (let i = 0; i < totalSegments; i++) {
        const seg = document.createElement('div');
        seg.className = 'progress-segment';
        segmentContainer.appendChild(seg);
      }

      try {
        // Обработка каждого файла
        for (let i = 0; i < files.length; i++) {
          if (isProcessingCancelled) break;

          // Сброс прогресс бара
          segmentContainer.querySelectorAll('.progress-segment').forEach(seg => {
            seg.classList.remove('active');
          });

          try {
            const file = files[i];
            totalOriginalSize += file.size;
            
            // Декодирование аудио
            const arrayBuffer = await file.arrayBuffer();
            const decoded = await activeAudioContext.decodeAudioData(arrayBuffer);
            
            // Статистика каналов
            if (decoded.numberOfChannels === 1) monoOriginal++;
            else if (decoded.numberOfChannels === 2) stereoOriginal++;
            
            // Получение настроек
            const fidelity = getSelectedValue('fidelity');
            const channels = getSelectedValue('channels');
            
            // Обработка аудио
            const converted = await convertChannels(decoded, channels);
            const downsampleRate = getDownsampleRate(fidelity, converted.sampleRate);
            const processed = await applySpeedAndFidelity(converted, 2.0, downsampleRate);
            
            // Генерация WAV
            const ko2Buffer = getKO2Buffer();
            const wavBlob = audioBufferToWav(processed, ko2Buffer);
            totalProcessedSize += wavBlob.size;
            
            // Добавление в ZIP
            const fileName = file.name.replace(/\.[^/.]+$/, '') + '_ko2.wav';
            zip.file(fileName, wavBlob);
            
            // Визуализация
            enqueueWaveformRender(wavBlob, fileName);
            
            // Анимация прогресса
            await animateProgress(i / files.length);
            
          } catch (error) {
            console.error('Error processing file:', error);
            fileInfo.innerHTML += `<div style="color:red">Error: ${error.message}</div>`;
          }

          // Добавляем паузу для предотвращения блокировки UI
          await new Promise(resolve => setTimeout(resolve, 0));
        }

        // Завершение прогресс бара
        segmentContainer.querySelectorAll('.progress-segment').forEach(seg => {
          seg.classList.add('active');
        });

        // Скачивание ZIP
        if (!isProcessingCancelled && zip.files.length > 0) {
          const zipBlob = await zip.generateAsync({ type: "blob" });
          const zipUrl = URL.createObjectURL(zipBlob);
          
          const a = document.createElement('a');
          a.href = zipUrl;
          a.download = "ko2_processed_audio.zip";
          a.click();
          
          // Освобождение памяти
          setTimeout(() => {
            URL.revokeObjectURL(zipUrl);
          }, 100);
          
          // Статистика
          fileInfo.innerHTML = `
            <div><b>Processed ${files.length} files</b></div>
            <div>Original: ${(totalOriginalSize / 1024 / 1024).toFixed(2)} MB</div>
            <div>Processed: ${(totalProcessedSize / 1024 / 1024).toFixed(2)} MB</div>
            <div>Fidelity: ${getSelectedValue('fidelity')}</div>
            <div>Channels: ${getSelectedValue('channels')}</div>
            <div>Pitch: ${document.getElementById('pitch-slider').value}</div>
            <div>Release: ${document.getElementById('release-slider').value}</div>
            <div>Stereo: ${stereoOriginal}, Mono: ${monoOriginal}</div>
          `;
        }
      } catch (error) {
        console.error('Processing failed:', error);
        fileInfo.innerHTML = `<div style="color:red">Fatal error: ${error.message}</div>`;
      } finally {
        // Закрытие оверлея после рендеринга
        waitForRenderCompletion().then(() => {
          overlay.style.display = 'none';
          loader.style.display = 'none';
          if (activeAudioContext) {
            activeAudioContext.close().catch(() => {});
            activeAudioContext = null;
          }
        });
      }
    }

    // Исправленная функция преобразования в WAV
    function audioBufferToWav(buffer, ko2Buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const length = buffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      
      // Создание WAV-заголовка
      const header = new ArrayBuffer(44);
      const view = new DataView(header);
      
      // Исправление: корректный расчет размера файла с метаданными
      const metadataSize = ko2Buffer ? 8 + ko2Buffer.length : 0;
      const dataSize = length * blockAlign;
      const riffSize = 36 + dataSize + metadataSize;
      
      // RIFF identifier
      writeString(view, 0, 'RIFF');
      // RIFF chunk length
      view.setUint32(4, riffSize, true);
      // RIFF type
      writeString(view, 8, 'WAVE');
      // Format chunk identifier
      writeString(view, 12, 'fmt ');
      // Format chunk length
      view.setUint32(16, 16, true);
      // Sample format (raw)
      view.setUint16(20, 1, true);
      // Channel count
      view.setUint16(22, numChannels, true);
      // Sample rate
      view.setUint32(24, sampleRate, true);
      // Byte rate (sample rate * block align)
      view.setUint32(28, sampleRate * blockAlign, true);
      // Block align (channel count * bytes per sample)
      view.setUint16(32, blockAlign, true);
      // Bits per sample
      view.setUint16(34, 16, true);
      // Data chunk identifier
      writeString(view, 36, 'data');
      // Data chunk length
      view.setUint32(40, dataSize, true);
      
      // Сборка аудиоданных
      const data = new Int16Array(length * numChannels);
      let offset = 0;
      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
          data[offset] = sample < 0 ? sample * 32768 : sample * 32767;
          offset++;
        }
      }
      
      // Добавление метаданных KO II
      if (ko2Buffer) {
        const metadata = new Uint8Array(8 + ko2Buffer.length);
        const metaView = new DataView(metadata.buffer);
        writeString(metaView, 0, 'TNGE');
        metaView.setUint32(4, ko2Buffer.length, true);
        metadata.set(ko2Buffer, 8);
        
        return new Blob(
          [header, data.buffer, metadata.buffer], 
          { type: 'audio/wav' }
        );
      }
      
      return new Blob([header, data.buffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    }

    // Визуализация волны с оптимизацией памяти
    function renderWaveform(blob, filename) {
      return new Promise((resolve) => {
        // Оптимизация: используем только часть файла для визуализации
        const slicedBlob = blob.size > 1024 * 1024 ? blob.slice(0, 1024 * 1024) : blob;
        
        // Создание контейнера
        const container = document.createElement('div');
        container.className = 'wave-container';
        
        // Заголовок
        const title = document.createElement('div');
        title.className = 'wave-title';
        try {
          title.textContent = decodeURIComponent(filename);
        } catch {
          title.textContent = filename;
        }
        
        // Контейнер волны
        const wave = document.createElement('div');
        wave.className = 'wave-element';
        
        // Кнопка воспроизведения
        const button = document.createElement('button');
        button.className = 'wave-button';
        button.innerHTML = '<i class="fas fa-play"></i> Play';
        
        // Добавление элементов
        container.appendChild(title);
        container.appendChild(wave);
        container.appendChild(button);
        document.getElementById('waveform-list').appendChild(container);
        
        try {
          // Инициализация Wavesurfer
          const wavesurfer = WaveSurfer.create({
            container: wave,
            waveColor: '#000',
            progressColor: '#000080',
            height: 64,
            barWidth: 1.4,
            minPxPerSec: 100,
            cursorColor: '#ff0000'
          });

          // Обработка готовности
          wavesurfer.on('ready', () => {
            button.addEventListener('click', () => {
              if (wavesurfer.isPlaying()) {
                wavesurfer.pause();
                button.innerHTML = '<i class="fas fa-play"></i> Play';
              } else {
                wavesurfer.play();
                button.innerHTML = '<i class="fas fa-pause"></i> Pause';
              }
            });
            resolve();
          });

          // Обработка ошибок
          wavesurfer.on('error', (err) => {
            console.error('Wavesurfer error:', err);
            wave.innerHTML = '<div class="render-error">Render failed: ' + err.message + '</div>';
            resolve();
          });

          // Загрузка
          wavesurfer.loadBlob(slicedBlob);
        } catch (err) {
          console.error('Wavesurfer init error:', err);
          wave.innerHTML = '<div class="render-error">Init failed: ' + err.message + '</div>';
          resolve();
        }
      });
    }

    // Управление очередью рендеринга
    function enqueueWaveformRender(blob, filename) {
      waveformQueue.push({ blob, filename });
      if (!waveformBusy) {
        processNextWaveform();
      }
    }

    async function processNextWaveform() {
      if (waveformQueue.length === 0) {
        waveformBusy = false;
        return;
      }

      waveformBusy = true;
      const { blob, filename } = waveformQueue.shift();
      
      try {
        // Добавляем задержку между рендерингом
        await new Promise(resolve => setTimeout(resolve, 200));
        await renderWaveform(blob, filename);
      } catch (err) {
        console.error('Waveform render error:', err);
      }
      
      // Обработка следующего элемента
      setTimeout(processNextWaveform, 0);
    }

    // Вспомогательные функции
    function animateProgress(progress) {
      return new Promise(resolve => {
        const segments = document.querySelectorAll('.progress-segment');
        const segmentsToActivate = Math.floor(progress * segments.length);
        
        segments.forEach((seg, i) => {
          if (i <= segmentsToActivate) {
            seg.classList.add('active');
          }
        });
        
        resolve();
      });
    }

    function waitForRenderCompletion() {
      return new Promise(resolve => {
        const check = () => {
          if (!waveformBusy && waveformQueue.length === 0) {
            resolve();
          } else {
            setTimeout(check, 100);
          }
        };
        check();
      });
    }

    // Аудио обработка
    function getSelectedValue(name) {
      const group = document.querySelector(`.win95-list[data-group="${name}"]`);
      return group?.querySelector('.list-item.selected')?.dataset.value || 'cd';
    }

    function getDownsampleRate(fidelity, originalRate) {
      switch (fidelity) {
        case 'sp8': return 10000;
        case 'sp16': return 16000;
        case 'sk': return 9000;
        default: return originalRate;
      }
    }

    async function convertChannels(buffer, channels) {
      const ctx = new OfflineAudioContext(
        channels === 'mono' ? 1 : 2, 
        buffer.length, 
        buffer.sampleRate
      );
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;

      if (channels === 'mono' && buffer.numberOfChannels > 1) {
        const merger = ctx.createChannelMerger(1);
        const splitter = ctx.createChannelSplitter(buffer.numberOfChannels);
        source.connect(splitter);
        for (let i = 0; i < buffer.numberOfChannels; i++) {
          splitter.connect(merger, i, 0);
        }
        merger.connect(ctx.destination);
      } else {
        source.connect(ctx.destination);
      }

      source.start();
      return await ctx.startRendering();
    }

    async function applySpeedAndFidelity(buffer, speed, sampleRate) {
      const duration = buffer.duration / speed;
      const ctx = new OfflineAudioContext(
        buffer.numberOfChannels,
        Math.ceil(duration * sampleRate),
        sampleRate
      );
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.playbackRate.value = speed;
      source.connect(ctx.destination);
      source.start();
      return await ctx.startRendering();
    }

    function getKO2Buffer() {
      const pitch = parseInt(document.getElementById('pitch-slider').value);
      const release = parseInt(document.getElementById('release-slider').value);
      
      const settings = {
        'sound.pitch': pitch,
        'sound.release': release,
        'sound.playmode': 'oneshot'
      };
      
      return new TextEncoder().encode(JSON.stringify(settings));
    }

    // Очистка при закрытии
    window.addEventListener('beforeunload', () => {
      if (activeAudioContext) {
        activeAudioContext.close().catch(() => {});
      }
    });
  </script>
</body>
</html>