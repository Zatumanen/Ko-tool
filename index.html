<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>SpeedUpperCut</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" type="image/svg+xml" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="24" y="40" width="16" height="16" fill="#e53935" stroke="black" stroke-width="2"/><rect x="26" y="44" width="12" height="4" fill="#b71c1c"/><polygon points="32,32 28,28 30,24 34,26 36,22 38,30" fill="orange" stroke="black" stroke-width="1"/></svg>'>
  <style>
    :root { 
      --glow-color: #ff3333; 
      --primary-blue: #000080;
      --win-gray: #c0c0c0;
      --win-light: #ffffff;
      --win-dark: #808080;
    }
    
    body {
      background: #008080;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      overflow-x: hidden;
      background-image: 
        radial-gradient(circle at 1px 1px, var(--win-dark) 1px, transparent 0),
        radial-gradient(circle at 1px 1px, var(--win-dark) 1px, transparent 0);
      background-size: 4px 4px;
      background-position: 0 0, 2px 2px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .desktop-icon {
      position: absolute;
      width: 80px;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 1px black;
      cursor: pointer;
      padding: 4px;
      user-select: none;
      transition: transform 0.2s;
    }
    
    .desktop-icon:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.05);
    }
    
    .window {
      width: 100%;
      max-width: 480px;
      background: var(--win-gray);
      border: 2px solid;
      border-top-color: var(--win-light);
      border-left-color: var(--win-light);
      border-right-color: var(--win-dark);
      border-bottom-color: var(--win-dark);
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      padding: 0;
      box-sizing: border-box;
      position: relative;
      z-index: 100;
    }
    
    .title-bar {
      background: var(--primary-blue);
      color: #fff;
      padding: 4px 8px;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid var(--win-gray);
      cursor: move;
      user-select: none;
    }
    
    .title-bar button {
      width: 20px;
      height: 20px;
      border: none;
      background: var(--win-gray);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-family: Arial, sans-serif;
      margin-left: 4px;
      border: 1px solid;
      border-top-color: var(--win-light);
      border-left-color: var(--win-light);
      border-right-color: var(--win-dark);
      border-bottom-color: var(--win-dark);
    }
    
    .title-bar button.minimize { 
      font-size: 18px;
      line-height: 12px;
    }
    
    .title-bar button.close { 
      font-size: 14px;
    }
    
    .title-bar button:active {
      border-top-color: var(--win-dark);
      border-left-color: var(--win-dark);
      border-right-color: var(--win-light);
      border-bottom-color: var(--win-light);
    }
    
    .content {
      padding: 12px;
      font-size: 14px;
      color: #000;
    }
    
    .drop-zone {
      border: 2px dashed #000;
      padding: 20px;
      text-align: center;
      background: rgba(255, 255, 255, 0.3);
      margin-top: 12px;
      position: relative;
      cursor: pointer;
      border-style: dotted;
      border-color: var(--win-dark);
    }
    
    .drop-zone.dragover {
      background: rgba(0, 128, 0, 0.3);
    }
    
    .drop-zone input[type="file"] {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    
    .drop-zone span {
      pointer-events: none;
      font-size: 16px;
      display: block;
      margin-top: 10px;
    }
    
    #file-info {
      margin-top: 10px;
      font-size: 14px;
      text-align: left;
      background: #fff;
      border: 2px inset var(--win-dark);
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    button {
      min-height: 44px;
      padding: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      border: 2px outset var(--win-gray);
      background: var(--win-gray);
      color: #000;
    }
    
    button:active {
      border-style: inset;
    }
    
    #overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 1000;
    }
    
    #win95-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 320px;
      padding: 12px;
      background: var(--win-gray);
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #000;
      z-index: 1001;
      border: 2px solid;
      border-top-color: var(--win-light);
      border-left-color: var(--win-light);
      border-right-color: var(--win-dark);
      border-bottom-color: var(--win-dark);
    }
    
    .progress-bar-container {
      background: #fff;
      border: 2px inset var(--win-dark);
      height: 24px;
      margin-top: 8px;
      display: flex;
      padding: 2px;
      gap: 1px;
      justify-content: flex-start;
    }
    
    .progress-segment {
      width: 8px;
      height: 100%;
      background: var(--win-gray);
    }
    
    .progress-segment.active {
      background: var(--primary-blue);
    }
    
    .win95-inset {
      border: 2px inset var(--win-dark);
      background: var(--win-gray);
      padding: 6px;
      margin-bottom: 6px;
    }
    
    .win95-list {
      border: 2px inset var(--win-dark);
      background: #fff;
      padding: 4px;
      font-family: 'Courier New', monospace;
      height: 100px;
      overflow-y: auto;
    }
    
    .list-item {
      padding: 8px 6px;
      cursor: pointer;
      user-select: none;
      font-size: 13px;
    }
    
    .list-item:hover {
      background: var(--primary-blue);
      color: white;
      transition: background 0.2s ease;
    }
    
    .list-item.selected {
      background: var(--primary-blue);
      color: white;
    }
    
    .wave-container {
      margin-bottom: 20px;
      border: 2px inset var(--win-dark);
      padding: 10px;
      background: #e0e0e0;
      position: relative;
    }
    
    .wave-title {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      margin-bottom: 6px;
      word-break: break-word;
      font-weight: bold;
      text-align: center;
    }
    
    .wave-element-container {
      width: 100%;
      height: 150px;
      background: #000;
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
      padding: 10px 0;
      box-sizing: border-box;
    }
    
    .wave-element {
      width: 100%;
      height: 100%;
    }
    
    .wave-button {
      font-family: 'Courier New', monospace;
      padding: 8px;
      background: var(--win-gray);
      border: 2px outset var(--win-gray);
      cursor: pointer;
      min-width: 80px;
    }
    
    .wave-button:active {
      border-style: inset;
    }
    
    .render-error {
      color: red;
      font-size: 13px;
      padding: 10px;
      background: #ffe6e6;
      border: 1px solid #ff9999;
    }
    
    .taskbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--win-gray);
      height: 36px;
      border-top: 2px solid var(--win-light);
      display: flex;
      align-items: center;
      padding: 0 8px;
      z-index: 90;
    }
    
    .start-button {
      padding: 4px 8px;
      background: var(--win-gray);
      border: 2px outset var(--win-gray);
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .start-button:active {
      border-style: inset;
    }
    
    .status-bar {
      margin-left: auto;
      padding: 0 8px;
      font-size: 14px;
    }
    
    .window-controls {
      display: flex;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .button-group button {
      flex: 1;
    }
    
    #cancel-button {
      margin-top: 10px;
      width: 100%;
      padding: 10px;
      background: var(--win-gray);
      border: 2px outset var(--win-gray);
      color: #000;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      cursor: pointer;
    }
    
    #cancel-button:active {
      border-style: inset;
    }
    
    .supported-formats {
      margin-top: 8px;
      font-size: 12px;
      color: #666;
    }
    
    .file-error {
      color: #d32f2f;
      background-color: #ffcdd2;
      border: 1px solid #f44336;
      padding: 8px;
      margin: 8px 0;
      border-radius: 2px;
      font-size: 13px;
    }
    
    .memory-warning {
      color: #ff6f00;
      background-color: #fff3e0;
      border: 1px solid #ff9800;
      padding: 8px;
      margin: 8px 0;
      border-radius: 2px;
      font-size: 13px;
      display: none;
    }
    
    .mobile-warning {
      color: #1976d2;
      background-color: #bbdefb;
      border: 1px solid #2196f3;
      padding: 8px;
      margin: 8px 0;
      border-radius: 2px;
      font-size: 13px;
      display: none;
    }
    
    .info-panel {
      background: #fff;
      border: 2px inset var(--win-dark);
      padding: 10px;
      margin-top: 10px;
      font-size: 13px;
      max-height: 150px;
      overflow-y: auto;
    }
    
    .trim-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    
    .wave-window {
      position: absolute;
      width: 500px;
      background: var(--win-gray);
      border: 2px solid;
      border-top-color: var(--win-light);
      border-left-color: var(--win-light);
      border-right-color: var(--win-dark);
      border-bottom-color: var(--win-dark);
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      padding: 0;
      box-sizing: border-box;
      z-index: 101;
      top: 100px;
      left: 100px;
    }
    
    .preview-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }

    .wave-element-container:empty::after {
      content: "Loading...";
      color: var(--win-dark);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .format-warning {
      color: #ff6f00;
      background-color: #fff3e0;
      border: 1px solid #ff9800;
      padding: 8px;
      margin: 8px 0;
      border-radius: 2px;
      font-size: 13px;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .window {
        width: 95vw;
        max-width: none;
        top: 10px;
        transform: scale(0.98);
      }
      
      .wave-element-container {
        height: 100px !important;
      }
      
      .desktop-icon {
        transform: scale(1.3);
        top: 10px !important;
        left: 5px !important;
      }
      
      .win95-list {
        height: 80px;
      }
      
      .list-item {
        padding: 6px 4px;
        font-size: 12px;
      }
      
      .wave-window {
        width: 90vw;
        left: 5vw;
        top: 20px;
      }
      
      .preview-controls {
        flex-direction: column;
        align-items: center;
      }
      
      .wave-button {
        min-width: 150px;
      }
    }

    @media (max-width: 768px) and (orientation: landscape) {
      .wave-element-container {
        height: 100px !important;
      }
    }
    
    .mobile-fallback {
      text-align: center;
      padding: 15px;
      background: white;
    }
    
    .mobile-fallback audio {
      width: 100%;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div class="desktop-icon" style="top: 20px; left: 30px;" onclick="document.querySelector('.window').style.display = 'block'">
    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4Ij4KICA8cmVjdCB4PSIyNCIgeT0iNDAiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0iI2U1MzkzNSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgPHJlY3QgeD0iMjYiIHk9IjQ0IiB3aWR0aD0iMTIiIGhlaWdodD0iNCIgZmlsbD0iI2I3MWMxYyIvPgogIDxwb2x5Z29uIHBvaW50cz0iMzIsMzIgMjgsMjggMzAsMjQgMzQsMjYgMzYsMjIgMzgsMzAiIGZpbGw9Im9yYW5nZSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxIi8+Cjwvc3ZnPg==" 
         width="48" height="48">
    <div>KO II Tool</div>
  </div>
  
  <div class="window">
    <div class="title-bar">
      <span>SpeedUpperCut</span>
      <div class="window-controls">
        <button class="minimize" title="Minimize">_</button>
        <button class="close" title="Close">×</button>
      </div>
    </div>
    <div class="content">
      <div class="memory-warning" id="memory-warning">
        <i class="fas fa-exclamation-triangle"></i>
        Processing large files may use significant memory. Close other tabs for best performance.
      </div>
      
      <div class="mobile-warning" id="mobile-warning">
        <i class="fas fa-mobile-alt"></i>
        Processing on mobile may be slow. Use small files for best results.
      </div>
      
      <div class="format-warning">
        <i class="fas fa-info-circle"></i>
        Files will be saved in their original format (MP3, WAV, etc.)
      </div>
      
      <div style="display: flex; gap: 8px; margin-bottom: 10px;">
        <div class="win95-inset" style="flex: 1;">
          <label>FIDELITY</label><br>
          <div class="win95-list" data-group="fidelity">
            <div data-value="cd" class="list-item selected">CD (16-bit, 44.1kHz)</div>
            <div data-value="sp8" class="list-item">SP-1200 (8-bit, 22kHz)</div>
            <div data-value="sp16" class="list-item">SP-1200 (16-bit, 22kHz)</div>
            <div data-value="sk" class="list-item">SK-1 (8-bit, 9kHz)</div>
          </div>
        </div>
        <div class="win95-inset" style="flex: 1;">
          <label>CHANNELS</label><br>
          <div class="win95-list" data-group="channels">
            <div data-value="stereo" class="list-item selected">Stereo</div>
            <div data-value="mono" class="list-item">Mono</div>
          </div>
        </div>
      </div>
      
      <div class="trim-control">
        <input type="checkbox" id="auto-trim" checked style="width: 16px; height: 16px;">
        <label for="auto-trim">Auto-trim silence at start/end</label>
      </div>
      
      <div class="drop-zone" id="drop-zone">
        <i class="fas fa-cloud-upload-alt" style="font-size: 36px;"></i>
        <input type="file" id="audio-upload" accept=".wav,.mp3,.aac,.ogg,.flac,audio/*" multiple />
        <input type="file" id="folder-upload" webkitdirectory directory multiple style="display: none;" />
        <span>DRAG AND DROP OR SELECT AUDIO FILES/FOLDERS</span>
        <div class="supported-formats">
          Supported: WAV, MP3, AAC, OGG, FLAC
        </div>
      </div>
      
      <div class="button-group">
        <button id="select-file-button">Select Files</button>
        <button id="select-folder-button">Select Folder</button>
        <button id="clear-button">Clear List</button>
      </div>
      
      <div class="info-panel" id="file-info">
        <div>Drop or select audio files/folders to process</div>
        <div>Files will be sped up 2x to save space</div>
        <div>Auto-trim removes silence at start and end</div>
        <div>Folder structure will be preserved in output</div>
        <div>Files will be saved in their original format</div>
        <div>KO II will convert files during import</div>
      </div>
    </div>
  </div>

  <div id="overlay">
    <div id="win95-loader">
      <div id="processing-title">Processing Audio Files...</div>
      <div class="progress-bar-container" id="segment-container"></div>
      <div id="current-file">Preparing...</div>
      <button id="cancel-button">Cancel Processing</button>
    </div>
  </div>

  <div class="taskbar">
    <div class="start-button">
      <i class="fas fa-bars"></i> Start
    </div>
    <div class="status-bar" id="status-bar">Ready</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/wavesurfer.js@7"></script>
  <script>
    // LameJS MP3 Encoder Wrapper
    class Mp3Encoder {
      constructor(channels, sampleRate, bitrate) {
        if (typeof lamejs === 'undefined') {
          throw new Error('LameJS library not loaded! MP3 encoding unavailable.');
        }
        
        this.channels = channels;
        this.sampleRate = sampleRate;
        this.bitrate = bitrate;
        this.lame = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
      }
      
      encode(audioBuffer) {
        const [left, right] = this.getAudioData(audioBuffer);
        const sampleBlockSize = 1152;
        const leftSamples = new Int16Array(sampleBlockSize);
        const rightSamples = new Int16Array(sampleBlockSize);
        const mp3Data = [];
        
        for (let i = 0; i < left.length; i += sampleBlockSize) {
          const leftChunk = left.subarray(i, i + sampleBlockSize);
          const rightChunk = this.channels > 1 
            ? right.subarray(i, i + sampleBlockSize) 
            : leftChunk;
          
          // Convert float to int16 with clamping
          for (let j = 0; j < leftChunk.length; j++) {
            const sampleLeft = Math.max(-1, Math.min(1, leftChunk[j]));
            leftSamples[j] = sampleLeft < 0 ? sampleLeft * 32768 : sampleLeft * 32767;
            
            if (this.channels > 1) {
              const sampleRight = Math.max(-1, Math.min(1, rightChunk[j]));
              rightSamples[j] = sampleRight < 0 ? sampleRight * 32768 : sampleRight * 32767;
            }
          }
          
          const mp3buf = this.lame.encodeBuffer(
            leftSamples.subarray(0, leftChunk.length),
            this.channels > 1 ? rightSamples.subarray(0, leftChunk.length) : undefined
          );
          
          if (mp3buf.length > 0) {
            mp3Data.push(new Int8Array(mp3buf));
          }
        }
        
        const lastChunk = this.lame.flush();
        if (lastChunk.length > 0) {
          mp3Data.push(new Int8Array(lastChunk));
        }
        
        return new Blob(mp3Data, { type: 'audio/mp3' });
      }
      
      getAudioData(audioBuffer) {
        const left = audioBuffer.getChannelData(0);
        let right = new Float32Array(audioBuffer.length); // Empty array for mono
        
        if (audioBuffer.numberOfChannels > 1) {
          right = audioBuffer.getChannelData(1);
        }
        
        return [left, right];
      }
    }

    const waveformQueue = [];
    let activeAudioContext = null;
    let createdObjectURLs = [];
    let dragCounter = 0;
    let processingCancelled = false;
    let currentProcessing = null;
    let lastProgress = 0;
    let windowZIndex = 100;
    let waveWindows = [];
    let audioContextInitialized = false;
    let memoryWarningShown = false;
    let audioContextResumed = false;
    const MAX_PREVIEW_WINDOWS = 5;
    const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB

    document.addEventListener('DOMContentLoaded', () => {
      initApp();
    });

    function isMobile() {
      return ('ontouchstart' in window) || 
             (navigator.maxTouchPoints > 0) || 
             (navigator.msMaxTouchPoints > 0);
    }

    function initApp() {
      if (isMobile()) {
        document.getElementById('mobile-warning').style.display = 'block';
      }
      
      checkMemoryAndWarn();
      
      document.querySelectorAll('.win95-list').forEach(group => {
        group.addEventListener('click', e => {
          if (e.target.classList.contains('list-item')) {
            group.querySelectorAll('.list-item').forEach(item => {
              item.classList.remove('selected');
            });
            e.target.classList.add('selected');
            updateStatus(`Fidelity set to: ${e.target.textContent}`);
          }
        });
      });

      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('audio-upload');
      const folderInput = document.getElementById('folder-upload');
      const selectFileButton = document.getElementById('select-file-button');
      const selectFolderButton = document.getElementById('select-folder-button');
      const clearButton = document.getElementById('clear-button');
      const cancelButton = document.getElementById('cancel-button');

      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleDrop);
      
      dropZone.addEventListener('touchmove', e => {
        e.preventDefault();
        dragCounter++;
        dropZone.classList.add('dragover');
      }, {passive: false});
      
      dropZone.addEventListener('touchend', handleDragLeave);
      
      selectFileButton.addEventListener('click', () => {
        fileInput.click();
        activateAudio();
      });
      
      selectFolderButton.addEventListener('click', () => {
        folderInput.click();
        activateAudio();
      });
      
      clearButton.addEventListener('click', () => {
        document.getElementById('file-info').innerHTML = 
          '<div>Drop or select audio files/folders to process</div>' +
          '<div>Files will be sped up 2x to save space</div>' +
          '<div>Auto-trim removes silence at start and end</div>' +
          '<div>Folder structure will be preserved in output</div>' +
          '<div>Files will be saved in their original format</div>' +
          '<div>KO II will convert files during import</div>';
        updateStatus("File list cleared");
      });
      
      fileInput.addEventListener('change', async (e) => {
        updateStatus(`Files selected: ${e.target.files.length}`);
        updateFileInfo(`<div>Selected ${e.target.files.length} file(s). Starting processing...</div>`);
        
        await ensureAudioContext();
        processFiles(e.target.files);
        e.target.value = null;
      });
      
      folderInput.addEventListener('change', async (e) => {
        updateStatus(`Folder selected with ${e.target.files.length} files`);
        updateFileInfo(`<div>Folder selected. Starting processing...</div>`);
        
        await ensureAudioContext();
        processFolder(e.target.files);
        e.target.value = null;
      });
      
      document.querySelector('.title-bar .minimize').addEventListener('click', () => {
        document.querySelector('.window').style.display = 'none';
      });
      
      document.querySelector('.title-bar .close').addEventListener('click', () => {
        document.querySelector('.window').style.display = 'none';
      });
      
      cancelButton.addEventListener('click', () => {
        processingCancelled = true;
        if (currentProcessing) {
          currentProcessing.cancel();
        }
        createdObjectURLs.forEach(url => {
          try {
            URL.revokeObjectURL(url);
          } catch (e) {}
        });
        createdObjectURLs = [];
        hideOverlay();
        updateStatus("Processing cancelled");
      });
      
      updateStatus("Ready to process files");
      
      const activationElements = [
        '#select-file-button', 
        '#select-folder-button',
        '.wave-button',
        '.wave-window',
        '#drop-zone'
      ];
      
      activationElements.forEach(selector => {
        document.querySelectorAll(selector).forEach(el => {
          el.addEventListener('click', activateAudio);
          el.addEventListener('touchstart', activateAudio);
        });
      });
    }
    
    async function ensureAudioContext() {
      if (!activeAudioContext) {
        initAudioContext();
      }
      
      if (activeAudioContext && activeAudioContext.state === 'suspended') {
        try {
          await activeAudioContext.resume();
          audioContextResumed = true;
          return true;
        } catch (e) {
          return false;
        }
      }
      return true;
    }
    
    function activateAudio() {
      if (!audioContextResumed && activeAudioContext) {
        try {
          if (activeAudioContext.state === 'suspended') {
            activeAudioContext.resume().then(() => {
              audioContextResumed = true;
            });
          }
        } catch (e) {}
      }
    }
    
    function initAudioContext() {
      if (!activeAudioContext) {
        try {
          const ContextClass = window.AudioContext || window.webkitAudioContext;
          activeAudioContext = new ContextClass();
          return activeAudioContext;
        } catch (e) {
          updateFileInfo(`<div class="file-error">AudioContext failed: ${e.message}</div>`);
          return null;
        }
      }
      return activeAudioContext;
    }
    
    function checkMemoryAndWarn() {
      if (memoryWarningShown) return;
      
      if (performance?.memory) {
        const totalJSHeapSize = performance.memory.totalJSHeapSize;
        const jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
        if (totalJSHeapSize > jsHeapSizeLimit * 0.7) {
          document.getElementById('memory-warning').style.display = 'block';
          memoryWarningShown = true;
        }
      } else if (navigator.deviceMemory && navigator.deviceMemory < 4) {
        document.getElementById('memory-warning').style.display = 'block';
        memoryWarningShown = true;
      }
    }

    function updateStatus(message) {
      document.getElementById('status-bar').textContent = message;
    }

    function updateCurrentFile(message) {
      const currentFileElement = document.getElementById('current-file');
      if (currentFileElement) {
        currentFileElement.textContent = message;
      }
    }

    function updateFileInfo(message) {
      const fileInfo = document.getElementById('file-info');
      if (!fileInfo) return;
      if (/<[a-z][\s\S]*>/i.test(message)) {
        fileInfo.insertAdjacentHTML('beforeend', message);
      } else {
        const div = document.createElement('div');
        div.textContent = message;
        fileInfo.appendChild(div);
      }
      fileInfo.scrollTop = fileInfo.scrollHeight;
    }

    function showOverlay() {
      document.getElementById('overlay').style.display = 'block';
      document.getElementById('win95-loader').style.display = 'block';
      processingCancelled = false;
      lastProgress = 0;
    }

    function hideOverlay() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('win95-loader').style.display = 'none';
    }

    function handleDragOver(e) {
      e.preventDefault();
      dragCounter++;
      document.getElementById('drop-zone').classList.add('dragover');
    }

    function handleDragLeave() {
      dragCounter--;
      if (dragCounter <= 0) {
        document.getElementById('drop-zone').classList.remove('dragover');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      dragCounter = 0;
      document.getElementById('drop-zone').classList.remove('dragover');
      
      if (e.dataTransfer.items) {
        const items = [];
        const queue = [];
        const entries = [];

        for (const item of e.dataTransfer.items) {
          if (item.kind === 'file') {
            const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : (item.getAsFile ? item.getAsFile() : null);
            if (entry && entry.isFile === undefined) {
              entries.push({ isFile: true, file: item.getAsFile(), name: item.getAsFile().name });
            } else if (entry) {
              entries.push(entry);
            }
          }
        }

        if (entries.length === 0) return;
        
        for (const entry of entries) {
          queue.push({ entry, path: '' });
        }
        
        processQueue(queue, items);
      } else if (e.dataTransfer.files.length > 0) {
        const items = Array.from(e.dataTransfer.files).map(file => ({
          file,
          path: file.name
        }));
        processItems(items);
      }
    }
    
    function processQueue(queue, items) {
      if (queue.length === 0) {
        processItems(items);
        return;
      }
      
      const queued = queue.shift();
      const entry = queued.entry;
      const path = queued.path || '';

      if (entry && entry.isFile === true && entry.file) {
        items.push({ file: entry.file, path: path + entry.name });
        return processQueue(queue, items);
      }

      if (!entry) {
        return processQueue(queue, items);
      }

      if (entry.isFile) {
        entry.file(file => {
          items.push({ file, path: path + file.name });
          processQueue(queue, items);
        }, err => {
          processQueue(queue, items);
        });
      } else if (entry.isDirectory) {
        const dirReader = entry.createReader();
        function readAll() {
          dirReader.readEntries(entries => {
            if (!entries || entries.length === 0) {
              processQueue(queue, items);
              return;
            }
            for (const childEntry of entries) {
              queue.push({
                entry: childEntry,
                path: path + entry.name + '/'
              });
            }
            readAll();
          }, err => {
            processQueue(queue, items);
          });
        }
        readAll();
      } else {
        processQueue(queue, items);
      }
    }

    async function processFiles(files) {
      if (!files || files.length === 0) return;
      
      updateStatus(`Selected ${files.length} file(s)`);
      updateFileInfo(`<div>Selected ${files.length} file(s). Processing started...</div>`);
      
      const items = Array.from(files).map(file => ({
        file,
        path: file.name
      }));
      
      await processItems(items);
    }

    async function processFolder(files) {
      if (!files || files.length === 0) return;
      
      updateStatus(`Folder selected with ${files.length} files`);
      updateFileInfo(`<div>Folder selected. Starting processing...</div>`);
      
      const items = [];
      
      for (const file of files) {
        const path = file.webkitRelativePath || file.name;
        items.push({ file, path });
      }
      
      await processItems(items);
    }

    async function processItems(items) {
      if (items.length === 0) {
        updateStatus("No files to process");
        return;
      }
      
      const segmentContainer = document.getElementById('segment-container');
      const fileInfo = document.getElementById('file-info');
      const cancelButton = document.getElementById('cancel-button');
      const autoTrim = document.getElementById('auto-trim').checked;

      showOverlay();
      fileInfo.innerHTML = '<div>Processing started...</div>';
      cancelButton.disabled = false;
      
      updateStatus(`Processing ${items.length} item(s)`);

      const zip = new JSZip();
      
      let stereoOriginal = 0;
      let monoOriginal = 0;
      let totalOriginalSize = 0;
      let totalProcessedSize = 0;
      let processedFiles = 0;
      let totalTrimmed = 0;

      segmentContainer.innerHTML = '';
      const totalSegments = 50;
      for (let i = 0; i < totalSegments; i++) {
        const seg = document.createElement('div');
        seg.className = 'progress-segment';
        segmentContainer.appendChild(seg);
      }

      currentProcessing = {
        cancel: () => {
          processingCancelled = true;
          if (activeAudioContext) {
            try {
              activeAudioContext.close();
            } catch (e) {
              console.error("Error closing AudioContext:", e);
            }
            activeAudioContext = null;
          }
          cancelButton.disabled = true;
          updateStatus("Processing cancelled");
        }
      };

      const BATCH_SIZE = 3;
      
      try {
        for (let batchStart = 0; batchStart < items.length; batchStart += BATCH_SIZE) {
          if (processingCancelled) break;
          
          const batchEnd = Math.min(batchStart + BATCH_SIZE, items.length);
          const batchItems = items.slice(batchStart, batchEnd);
          
          const results = [];
          
          for (const item of batchItems) {
            if (processingCancelled) break;
            
            try {
              const result = await processSingleItem(item, batchStart + results.length, items.length, zip);
              if (result) {
                results.push(result);
              }
            } catch (error) {
              handleProcessingError(error, item);
            }
          }
          
          for (const result of results) {
            if (!result) continue;
            
            processedFiles++;
            totalOriginalSize += result.originalSize || 0;
            totalProcessedSize += result.processedSize || 0;
            totalTrimmed += result.trimmedSamples || 0;
            
            if (result.channels === 1) monoOriginal++;
            else if (result.channels === 2) stereoOriginal++;
            
            await updateProgressBar(processedFiles / items.length);
          }
        }

        if (!processingCancelled && processedFiles > 0) {
          const zipBlob = await zip.generateAsync({ 
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: { level: 6 }
          }, metadata => {
            const progress = metadata?.percent ? (metadata.percent / 100) : 0;
            updateStatus(`Compressing: ${metadata.percent ? metadata.percent.toFixed(1) : 0}%`);
          });
          
          await updateProgressBar(1);
          
          const zipUrl = URL.createObjectURL(zipBlob);
          createdObjectURLs.push(zipUrl);
          
          const a = document.createElement('a');
          a.href = zipUrl;
          a.download = "ko2_processed_audio.zip";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          setTimeout(() => {
            try {
              URL.revokeObjectURL(zipUrl);
            } catch (e) {}
            createdObjectURLs = createdObjectURLs.filter(url => url !== zipUrl);
          }, 2000);
          
          const fidelity = getSelectedValue('fidelity');
          const channels = getSelectedValue('channels');
          
          fileInfo.innerHTML += `
            <div><b>Processed ${processedFiles} files</b></div>
            <div>Original size: ${formatBytes(totalOriginalSize)}</div>
            <div>Processed size: ${formatBytes(totalProcessedSize)}</div>
            <div>Space saved: ${totalOriginalSize > 0 ? (100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1) : '0'}%</div>
          `;
          
          if (autoTrim && totalTrimmed > 0) {
            fileInfo.innerHTML += `<div>Total silence trimmed: ${(totalTrimmed/44100).toFixed(2)}s</div>`;
          }
          
          fileInfo.innerHTML += `
            <div>Fidelity: ${fidelity.toUpperCase()}</div>
            <div>Channels: ${channels}</div>
            <div>Stereo: ${stereoOriginal}, Mono: ${monoOriginal}</div>
          `;
          
          updateStatus(`Processed ${processedFiles} files. Space saved: ${totalOriginalSize > 0 ? (100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1) : '0'}%`);
        }
      } catch (error) {
        if (!processingCancelled) {
          handleProcessingError(error);
        }
      } finally {
        if (!processingCancelled) {
          hideOverlay();
        }
        
        if (activeAudioContext) {
          try { 
            activeAudioContext.close(); 
          } catch(e) {}
          activeAudioContext = null;
          audioContextResumed = false;
        }
        
        currentProcessing = null;
      }
    }

    async function processSingleItem(item, index, total, zip) {
      const file = item.file;
      let decoded, processed;
      let originalSize = file.size;
      let processedSize = 0;
      let trimmedSamples = 0;
      let fileName = '';
      let channels = 0;
      let isCompressed = false;
      
      try {
        updateCurrentFile(`Processing: ${item.path} (${index+1}/${total})`);
        updateFileInfo(`<div>Processing: ${escapeHtml(item.path)}</div>`);
        
        if (!isSupportedAudioType(file.type, file.name)) {
          throw new Error(`Unsupported file type: ${file.type || file.name.split('.').pop()}`);
        }
        
        if (file.size > MAX_FILE_SIZE) {
          throw new Error(`File size exceeds limit (${(file.size/(1024*1024)).toFixed(1)}MB)`);
        }
        
        // Determine file extension and compression status
        const fileExtension = (file.name.split('.').pop() || 'wav').toLowerCase();
        const compressedFormats = ['mp3', 'ogg', 'aac', 'm4a'];
        isCompressed = compressedFormats.includes(fileExtension);
        
        if (!activeAudioContext) {
          await ensureAudioContext();
        }
        
        const arrayBuffer = await file.arrayBuffer();
        if (processingCancelled) return null;
        
        decoded = await decodeAudioSafe(arrayBuffer);
        if (processingCancelled) return null;
        
        channels = decoded.numberOfChannels;
        
        const fidelity = getSelectedValue('fidelity');
        const channelsSetting = getSelectedValue('channels');
        const autoTrim = document.getElementById('auto-trim').checked;
        
        processed = await processAudio(decoded, fidelity, channelsSetting);
        if (processingCancelled) return null;
        
        if (autoTrim) {
          const beforeLength = processed.length;
          processed = trimSilence(processed);
          const afterLength = processed.length;
          trimmedSamples = Math.max(0, beforeLength - afterLength);
          
          updateFileInfo(`<div>Trimmed: ${(trimmedSamples/processed.sampleRate).toFixed(2)}s silence</div>`);
        }
        
        const pathParts = item.path.split('/');
        const origFilename = pathParts.pop();
        const safeFilename = origFilename.replace(/[^\w\.\-]/gi, '');
        const newFilename = safeFilename.replace(/\.[^/.]+$/, '') + '_ko2.' + fileExtension;
        fileName = [...pathParts, newFilename].join('/');
        
        // Encode to original format with error handling
        let outputBlob;
        try {
          if (fileExtension === 'mp3') {
            // Use LameJS for MP3 encoding
            const encoder = new Mp3Encoder(
              processed.numberOfChannels, 
              processed.sampleRate, 
              192 // 192 kbps bitrate
            );
            outputBlob = encoder.encode(processed);
          } else {
            // For other formats, use WAV
            outputBlob = await audioBufferToBlob(processed);
          }
        } catch (encodeError) {
          console.error("Encoding error:", encodeError);
          updateFileInfo(`<div class="file-error">Encoding error: ${encodeError.message}. Falling back to WAV format.</div>`);
          outputBlob = await audioBufferToBlob(processed);
        }
        
        processedSize = outputBlob.size;
        
        try {
          zip.file(fileName, outputBlob);
        } catch (zipError) {
          throw new Error(`Failed to add to ZIP: ${zipError.message}`);
        }
        
        const originalSizeKB = (originalSize / 1024).toFixed(1);
        const processedSizeKB = (processedSize / 1024).toFixed(1);
        const sizeDifference = processedSize - originalSize;
        let sizeInfo;
        
        if (sizeDifference > 0) {
          sizeInfo = `INCREASED by ${(sizeDifference/1024).toFixed(1)}KB`;
        } else {
          sizeInfo = `DECREASED by ${(-sizeDifference/1024).toFixed(1)}KB`;
        }
        
        // Add compression info
        let compressionInfo = '';
        if (isCompressed) {
          compressionInfo = `<div>Original compressed format preserved</div>`;
        }
        
        updateFileInfo(`
          <div>Processed: ${escapeHtml(fileName)}</div>
          <div>Original: ${originalSizeKB}KB → Processed: ${processedSizeKB}KB</div>
          <div>${sizeInfo}</div>
          ${compressionInfo}
        `);
        
        const url = URL.createObjectURL(outputBlob);
        createdObjectURLs.push(url);
        
        createWaveWindow(fileName, url, processed);
        
        return {
          fileName: fileName,
          url: url,
          originalSize: originalSize,
          processedSize: processedSize,
          trimmedSamples: trimmedSamples,
          channels: channels,
          isCompressed: isCompressed
        };
        
      } catch (error) {
        if (!processingCancelled) {
          handleProcessingError(error, item);
        }
        return null;
      } finally {
        decoded = null;
        processed = null;
        await new Promise(resolve => setTimeout(resolve, 0));
        if (window.gc) window.gc();
      }
    }

    function getMimeType(extension) {
      const types = {
        'wav': 'audio/wav',
        'mp3': 'audio/mpeg',
        'ogg': 'audio/ogg',
        'flac': 'audio/flac',
        'aac': 'audio/aac',
        'm4a': 'audio/mp4'
      };
      return types[extension] || 'audio/wav';
    }

    async function audioBufferToBlob(audioBuffer) {
      return audioBufferToWav(audioBuffer);
    }

    function calculateRMS(data, start, end) {
      let sum = 0;
      for (let i = start; i < end; i++) {
        const sample = data[i];
        sum += sample * sample;
      }
      return Math.sqrt(sum / (end - start));
    }

    function trimSilence(audioBuffer, thresholdDb = -60, minSilenceDuration = 0.1) {
      const threshold = Math.pow(10, thresholdDb / 20);
      const sampleRate = audioBuffer.sampleRate;
      const minSilenceSamples = Math.floor(minSilenceDuration * sampleRate);
      const channelData = audioBuffer.getChannelData(0);
      const length = channelData.length;

      const blockSize = 1024;
      let startIndex = 0;
      let endIndex = length - 1;

      for (let i = 0; i < length; i += blockSize) {
        const blockEnd = Math.min(i + blockSize, length);
        const rms = calculateRMS(channelData, i, blockEnd);
        if (rms > threshold) {
          startIndex = Math.max(0, i - blockSize);
          break;
        }
      }

      for (let i = length - blockSize; i >= 0; i -= blockSize) {
        const blockEnd = Math.min(i + blockSize, length);
        const rms = calculateRMS(channelData, i, blockEnd);
        if (rms > threshold) {
          endIndex = Math.min(length - 1, i + blockSize);
          break;
        }
      }

      startIndex = findExactStart(channelData, startIndex, threshold);
      endIndex = findExactEnd(channelData, endIndex, threshold);

      startIndex = Math.max(0, startIndex - Math.floor(0.05 * sampleRate));
      endIndex = Math.min(length - 1, endIndex + Math.floor(0.05 * sampleRate));

      if (startIndex >= endIndex) {
        return audioBuffer;
      }

      const newLength = endIndex - startIndex + 1;
      const newBuffer = new AudioBuffer({
        length: newLength,
        sampleRate: audioBuffer.sampleRate,
        numberOfChannels: audioBuffer.numberOfChannels
      });

      for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
        const sourceData = audioBuffer.getChannelData(ch);
        const targetData = newBuffer.getChannelData(ch);
        targetData.set(sourceData.subarray(startIndex, endIndex + 1));
      }

      return newBuffer;
    }

    function findExactStart(data, roughStart, threshold) {
      for (let i = roughStart; i >= 0; i--) {
        if (Math.abs(data[i]) > threshold) {
          return i;
        }
      }
      return roughStart;
    }

    function findExactEnd(data, roughEnd, threshold) {
      for (let i = roughEnd; i < data.length; i++) {
        if (Math.abs(data[i]) > threshold) {
          return i;
        }
      }
      return roughEnd;
    }

    function formatBytes(bytes) {
      if (!bytes) return '0 B';
      if (bytes < 1024) return bytes + ' B';
      else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      else return (bytes / 1048576).toFixed(1) + ' MB';
    }

    function handleProcessingError(error, item) {
      const errorMessage = error?.message ? error.message : String(error);
      const fileName = item?.file?.name || 'unknown file';
      
      console.error(`Processing error for ${fileName}:`, error);
      
      document.getElementById('file-info').innerHTML += `
        <div class="file-error">
          <strong>Error processing:</strong> ${escapeHtml(fileName)}<br>
          ${escapeHtml(errorMessage)}
        </div>
      `;
      
      updateStatus(`Error: ${escapeHtml(errorMessage)} (${escapeHtml(fileName)})`);
      
      if (errorMessage.toLowerCase().includes('memory') || 
          errorMessage.toLowerCase().includes('allocation')) {
        if (activeAudioContext) {
          try { activeAudioContext.close(); } catch(e) {}
          activeAudioContext = null;
        }
        document.getElementById('memory-warning').style.display = 'block';
        memoryWarningShown = true;
      }
    }

    function isSupportedAudioType(mimeType, fileName) {
      const supportedTypes = [
        'audio/wav', 'audio/wave', 'audio/x-wav',
        'audio/mpeg', 'audio/mp3',
        'audio/ogg', 'audio/vorbis',
        'audio/aac', 'audio/aacp',
        'audio/flac', 'audio/x-flac'
      ];
      
      const ext = fileName.split('.').pop().toLowerCase();
      const supportedExts = ['wav', 'mp3', 'ogg', 'aac', 'flac', 'm4a'];
      
      return supportedTypes.includes(mimeType) || supportedExts.includes(ext);
    }

    async function decodeAudioSafe(arrayBuffer) {
      if (!activeAudioContext) throw new Error("AudioContext is not available");
      try {
        return await activeAudioContext.decodeAudioData(arrayBuffer.slice(0));
      } catch (e) {
        throw new Error('Audio decoding failed: ' + (e?.message ? e.message : String(e)));
      }
    }

    function getSelectedValue(name) {
      const group = document.querySelector(`.win95-list[data-group="${name}"]`);
      return group?.querySelector('.list-item.selected')?.dataset.value || 'cd';
    }

    function getFidelitySettings(fidelity) {
      switch (fidelity) {
        case 'sp8': return { sampleRate: 22050, bitDepth: 8 };
        case 'sp16': return { sampleRate: 22050, bitDepth: 16 };
        case 'sk': return { sampleRate: 9000, bitDepth: 8 };
        default: return { sampleRate: 44100, bitDepth: 16 };
      }
    }

    async function processAudio(buffer, fidelity, channels) {
      const fidelitySettings = getFidelitySettings(fidelity);
      const targetChannels = channels === 'mono' ? 1 : 2;
      const speedFactor = 2.0;
      
      const converted = await convertChannels(buffer, targetChannels);
      return await applySpeedAndFidelity(converted, speedFactor, fidelitySettings.sampleRate);
    }

    function checkOfflineAudioContextSupport() {
      if (!window.OfflineAudioContext && !window.webkitOfflineAudioContext) {
        throw new Error("OfflineAudioContext is not supported in this browser.");
      }
    }

    async function convertChannels(buffer, targetChannels) {
      checkOfflineAudioContextSupport();
      
      if (buffer.numberOfChannels === targetChannels) return buffer;

      const OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
      const ctx = new OfflineContext(
        targetChannels, 
        buffer.length, 
        buffer.sampleRate
      );
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      
      if (targetChannels === 1 && buffer.numberOfChannels > 1) {
        const merger = ctx.createChannelMerger(1);
        const splitter = ctx.createChannelSplitter(buffer.numberOfChannels);
        source.connect(splitter);
        
        const gain = ctx.createGain();
        gain.gain.value = 1 / buffer.numberOfChannels;
        
        for (let i = 0; i < buffer.numberOfChannels; i++) {
          splitter.connect(gain, i);
        }
        
        gain.connect(merger, 0, 0);
        merger.connect(ctx.destination);
      } 
      else if (targetChannels === 2 && buffer.numberOfChannels === 1) {
        const merger = ctx.createChannelMerger(2);
        source.connect(merger, 0, 0);
        source.connect(merger, 0, 1);
        merger.connect(ctx.destination);
      } 
      else {
        source.connect(ctx.destination);
      }
      
      source.start();
      const result = await ctx.startRendering();
      
      return result;
    }

    async function applySpeedAndFidelity(buffer, speed, sampleRate) {
      checkOfflineAudioContextSupport();
      
      const duration = buffer.duration / speed;
      
      const OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
      const ctx = new OfflineContext(
        buffer.numberOfChannels,
        Math.ceil(duration * sampleRate),
        sampleRate
      );
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.playbackRate.value = speed;
      source.connect(ctx.destination);
      source.start();
      const result = await ctx.startRendering();
      
      return result;
    }

    function writeKO2ChunkBuf(pitch = -12, release = 255, playmode = 1) {
      const data = new Uint8Array(12);
      
      // Идентификатор чанка "ko2 "
      data[0] = 0x6B; // 'k'
      data[1] = 0x6F; // 'o'
      data[2] = 0x32; // '2'
      data[3] = 0x20; // ' '
      
      // Размер данных чанка (4 байта, little-endian)
      data[4] = 0x04; // Размер данных = 4
      data[5] = 0x00;
      data[6] = 0x00;
      data[7] = 0x00;
      
      // Данные чанка
      data[8] = pitch;   // Pitch (1 байт со знаком)
      data[9] = release; // Release (1 байт без знака)
      data[10] = 0x00;   // Зарезервированный байт (0)
      data[11] = playmode; // Playmode (1 байт)
      
      return data.buffer;
    }

    function audioBufferToWav(audioBuffer) {
      const fidelity = getSelectedValue('fidelity');
      const fidelitySettings = getFidelitySettings(fidelity);
      const bitDepth = fidelitySettings.bitDepth;
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const bytesPerSample = (bitDepth === 8) ? 1 : 2;
      const blockAlign = numChannels * bytesPerSample;
      const dataLength = audioBuffer.length * blockAlign;

      const fmtChunkSize = 16;
      const fmtBuf = new ArrayBuffer(8 + fmtChunkSize);
      const fmtDv = new DataView(fmtBuf);
      writeString(fmtDv, 0, 'fmt ');
      fmtDv.setUint32(4, fmtChunkSize, true);
      fmtDv.setUint16(8, 1, true);
      fmtDv.setUint16(10, numChannels, true);
      fmtDv.setUint32(12, sampleRate, true);
      fmtDv.setUint32(16, sampleRate * blockAlign, true);
      fmtDv.setUint16(20, blockAlign, true);
      fmtDv.setUint16(22, bitDepth, true);

      // Используем исправленную версию для чанка KO II
      const ko2Buf = writeKO2ChunkBuf();

      const dataHeader = new ArrayBuffer(8);
      const dataDv = new DataView(dataHeader);
      writeString(dataDv, 0, 'data');
      dataDv.setUint32(4, dataLength, true);

      const riffSize = 4 + fmtBuf.byteLength + ko2Buf.byteLength + dataHeader.byteLength + dataLength;
      const riffHeader = new ArrayBuffer(12);
      const riffDv = new DataView(riffHeader);
      writeString(riffDv, 0, 'RIFF');
      riffDv.setUint32(4, riffSize, true);
      writeString(riffDv, 8, 'WAVE');

      let audioData;
      if (bitDepth === 8) {
        audioData = new Uint8Array(dataLength);
        let off = 0;
        for (let i = 0; i < audioBuffer.length; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            const s = audioBuffer.getChannelData(ch)[i];
            const u = Math.max(0, Math.min(255, Math.round((s + 1) * 127.5)));
            audioData[off++] = u;
          }
        }
      } else {
        const tmp = new Int16Array(audioBuffer.length * numChannels);
        let off = 0;
        for (let i = 0; i < audioBuffer.length; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            const s = Math.max(-1, Math.min(1, audioBuffer.getChannelData(ch)[i]));
            const v = s < 0 ? Math.round(s * 32768) : Math.round(s * 32767);
            tmp[off++] = v;
          }
        }
        audioData = tmp.buffer;
      }

      return new Blob([riffHeader, fmtBuf, ko2Buf, dataHeader, audioData], { type: 'audio/wav' });
    }

    function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    }

    function createWaveWindow(title, url, audioBuffer) {
      if (waveWindows.length >= MAX_PREVIEW_WINDOWS) {
        const oldestWindow = waveWindows.shift();
        if (oldestWindow && oldestWindow.element) {
          try {
            if (oldestWindow.element.wavesurfer) {
              oldestWindow.element.wavesurfer.destroy();
            }
            URL.revokeObjectURL(oldestWindow.url);
            document.body.removeChild(oldestWindow.element);
          } catch (e) {}
        }
      }
      
      windowZIndex += 2;
      const windowId = 'wave-window-' + Date.now();
      
      const top = 80 + (waveWindows.length * 30);
      const left = 100 + (waveWindows.length * 30);
      
      const windowElement = document.createElement('div');
      windowElement.className = 'wave-window window';
      windowElement.id = windowId;
      windowElement.style.zIndex = windowZIndex;
      windowElement.style.top = top + 'px';
      windowElement.style.left = left + 'px';
      
      windowElement.innerHTML = `
        <div class="title-bar">
          <span>${escapeHtml(title)}</span>
          <div class="window-controls">
            <button class="minimize" title="Minimize">_</button>
            <button class="close" title="Close">×</button>
          </div>
        </div>
        <div class="content">
          <div class="wave-container">
            <div class="wave-title">${escapeHtml(title)}</div>
            <div class="wave-element-container">
              <div class="wave-element"></div>
            </div>
            <div class="preview-controls">
              <button class="wave-button play-button">
                <i class="fas fa-play"></i> Play
              </button>
              <button class="wave-button pause-button" style="display: none;">
                <i class="fas fa-pause"></i> Pause
              </button>
              <button class="wave-button stop-button">
                <i class="fas fa-stop"></i> Stop
              </button>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(windowElement);
      
      const playButton = windowElement.querySelector('.play-button');
      const pauseButton = windowElement.querySelector('.pause-button');
      const stopButton = windowElement.querySelector('.stop-button');
      const waveContainer = windowElement.querySelector('.wave-element');
      
      const minimizeBtn = windowElement.querySelector('.minimize');
      minimizeBtn.addEventListener('click', () => {
        const content = windowElement.querySelector('.content');
        content.style.display = content.style.display === 'none' ? 'block' : 'none';
      });
      
      const closeBtn = windowElement.querySelector('.close');
      closeBtn.addEventListener('click', () => {
        if (windowElement.wavesurfer) {
          try {
            windowElement.wavesurfer.destroy();
          } catch(e) {}
        }
        try {
          URL.revokeObjectURL(url);
        } catch (e) {}
        createdObjectURLs = createdObjectURLs.filter(u => u !== url);
        document.body.removeChild(windowElement);
        waveWindows = waveWindows.filter(w => w.id !== windowId);
      });
      
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      const titleBar = windowElement.querySelector('.title-bar');
      titleBar.addEventListener('mousedown', dragMouseDown);
      
      function dragMouseDown(e) {
        e.preventDefault();
        windowZIndex += 2;
        windowElement.style.zIndex = windowZIndex;
        
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.addEventListener('mouseup', closeDragElement);
        document.addEventListener('mousemove', elementDrag);
      }
      
      function elementDrag(e) {
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        windowElement.style.top = (windowElement.offsetTop - pos2) + "px";
        windowElement.style.left = (windowElement.offsetLeft - pos1) + "px";
      }
      
      function closeDragElement() {
        document.removeEventListener('mouseup', closeDragElement);
        document.removeEventListener('mousemove', elementDrag);
      }
      
      try {
        const WaveSurferLib = window.WaveSurfer?.default || window.WaveSurfer;
        if (!WaveSurferLib) throw new Error('WaveSurfer not loaded');
        
        const wavesurfer = WaveSurferLib.create({
          container: waveContainer,
          height: '100%',
          barWidth: 2,
          barGap: 1,
          barRadius: 1,
          cursorWidth: 1,
          cursorColor: 'transparent',
          normalize: true,
          progressColor: '#000080',
          waveColor: '#c0c0c0',
          fillParent: true,
          interact: false,
          backend: isMobile() ? 'MediaElement' : 'WebAudio'
        });
        
        windowElement.wavesurfer = wavesurfer;
        
        playButton.addEventListener('click', () => {
          activateAudio();
          wavesurfer.play();
          playButton.style.display = 'none';
          pauseButton.style.display = 'block';
          updateStatus("Playing processed audio");
        });
        
        pauseButton.addEventListener('click', () => {
          wavesurfer.pause();
          pauseButton.style.display = 'none';
          playButton.style.display = 'block';
          updateStatus("Playback paused");
        });
        
        stopButton.addEventListener('click', () => {
          wavesurfer.stop();
          pauseButton.style.display = 'none';
          playButton.style.display = 'block';
          updateStatus("Playback stopped");
        });
        
        wavesurfer.load(url);
        
        wavesurfer.on('error', (err) => {
          waveContainer.innerHTML = `
            <div class="file-error">
              WaveSurfer error: ${escapeHtml(err.message || 'Failed to load audio')}
            </div>
          `;
          playButton.style.display = 'none';
          pauseButton.style.display = 'none';
        });
        
      } catch (e) {
        waveContainer.innerHTML = `
          <div class="file-error">
            WaveSurfer failed: ${escapeHtml(e.message || 'Audio preview not available')}
          </div>
          <div class="mobile-fallback">
            <audio controls src="${url}" style="width: 100%;"></audio>
          </div>
        `;
        playButton.style.display = 'none';
        pauseButton.style.display = 'none';
      }
      
      const windowObj = {
        id: windowId,
        element: windowElement,
        url: url
      };
      
      waveWindows.push(windowObj);
      return windowElement;
    }

    function updateProgressBar(progress) {
      return new Promise(resolve => {
        progress = Math.max(0, Math.min(1, progress));
        
        const segments = document.querySelectorAll('.progress-segment');
        const segmentsToActivate = Math.floor(progress * segments.length);
        
        for (let i = 0; i < segments.length; i++) {
          const shouldBeActive = i < segmentsToActivate;
          const isActive = segments[i].classList.contains('active');
          
          if (shouldBeActive !== isActive) {
            segments[i].classList.toggle('active', shouldBeActive);
          }
        }
        
        lastProgress = progress;
        
        setTimeout(resolve, 20);
      });
    }

    window.addEventListener('beforeunload', () => {
      createdObjectURLs.forEach(url => {
        try { URL.revokeObjectURL(url); } catch(e) {}
      });
      if (activeAudioContext) {
        try { activeAudioContext.close(); } catch(e) {}
      }
    });

    function escapeHtml(str) {
      if (str == null) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
</body>
</html>