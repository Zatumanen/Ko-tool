<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KO II SpeedUpperCut v0.0.16</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    body {
      background: #008080;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      overflow-x: hidden;
      background-image: 
        radial-gradient(circle at 1px 1px, #808080 1px, transparent 0),
        radial-gradient(circle at 1px 1px, #808080 1px, transparent 0);
      background-size: 4px 4px;
      background-position: 0 0, 2px 2px;
    }
    .desktop-icon {
      position: absolute;
      width: 80px;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 1px black;
      cursor: pointer;
      padding: 4px;
      user-select: none;
    }
    .desktop-icon:hover {
      background: rgba(255,255,255,0.2);
    }
    .window {
      width: 100%;
      max-width: 480px;
      background: #c0c0c0;
      border: 2px solid;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      border-right-color: #808080;
      border-bottom-color: #808080;
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      padding: 0;
      box-sizing: border-box;
      position: relative;
      z-index: 100;
    }
    .title-bar {
      background: #000080;
      color: #fff;
      padding: 4px 8px;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #c0c0c0;
      cursor: move;
    }
    .title-bar button {
      width: 20px;
      height: 20px;
      border: none;
      background: #c0c0c0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-family: Arial, sans-serif;
      margin-left: 4px;
      border: 1px solid;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      border-right-color: #808080;
      border-bottom-color: #808080;
    }
    .title-bar button.minimize { 
      background: #c0c0c0; 
      font-size: 18px;
      line-height: 12px;
    }
    .title-bar button.close { 
      background: #c0c0c0; 
      font-size: 14px;
    }
    .title-bar button:active {
      border-top-color: #808080;
      border-left-color: #808080;
      border-right-color: #ffffff;
      border-bottom-color: #ffffff;
    }
    .content {
      padding: 12px;
      font-size: 14px;
      color: #000;
    }
    .settings {
      margin-top: 10px;
      padding: 8px;
      background: #c0c0c0;
      border: 2px inset #808080;
    }
    .slider {
      width: 100%;
      height: 12px;
      background: #000;
      appearance: none;
      outline: none;
    }
    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      background: #c0c0c0;
      border: 1px solid;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      border-right-color: #808080;
      border-bottom-color: #808080;
      cursor: pointer;
    }
    .drop-zone {
      border: 2px dashed #000;
      padding: 20px;
      text-align: center;
      background: rgba(255, 255, 255, 0.3);
      margin-top: 12px;
      position: relative;
      cursor: pointer;
      border-style: dotted;
      border-color: #808080;
    }
    .drop-zone.dragover {
      background: rgba(0, 128, 0, 0.3);
    }
    .drop-zone input[type="file"] {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .drop-zone span {
      pointer-events: none;
      font-size: 16px;
      display: block;
      margin-top: 10px;
    }
    #file-info {
      margin-top: 10px;
      font-size: 14px;
      text-align: left;
      background: #fff;
      border: 2px inset #808080;
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    button#select-file-button {
      width: 100%;
      margin-top: 10px;
      background: #c0c0c0;
      border: 2px outset #c0c0c0;
      color: #000;
      font-family: 'Courier New', monospace;
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    button#select-file-button:active {
      border-style: inset;
    }
    #overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 1000;
    }
    #win95-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 320px;
      padding: 12px;
      background: #c0c0c0;
      border: 2px solid #000;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #000;
      z-index: 1001;
      border: 2px solid;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      border-right-color: #808080;
      border-bottom-color: #808080;
    }
    .progress-bar-container {
      background: #fff;
      border: 2px inset #808080;
      height: 24px;
      margin-top: 8px;
      display: flex;
      padding: 2px;
      gap: 1px;
      justify-content: flex-start;
    }
    .progress-segment {
      width: 8px;
      height: 100%;
      background: #c0c0c0;
    }
    .progress-segment.active {
      background: #000080;
    }
    .slider-wrapper {
      display: flex;
      align-items: center;
      margin-top: 8px;
      gap: 8px;
    }
    .slider-value {
      background: #fff;
      border: 2px inset #808080;
      padding: 2px 6px;
      font-size: 14px;
      min-width: 36px;
      text-align: center;
      font-family: 'Courier New', monospace;
      color: #000;
    }
    .win95-inset {
      border: 2px inset #808080;
      background: #c0c0c0;
      padding: 6px;
      margin-bottom: 6px;
    }
    .win95-list {
      border: 2px inset #808080;
      background: #fff;
      padding: 4px;
      font-family: 'Courier New', monospace;
      height: 100px;
      overflow-y: auto;
    }
    .list-item {
      padding: 4px 6px;
      cursor: pointer;
      user-select: none;
      font-size: 13px;
    }
    .list-item:hover {
      background: #000080;
      color: white;
    }
    .list-item.selected {
      background: #000080;
      color: white;
    }
    .wave-container {
      margin-bottom: 20px;
      border: 2px inset #808080;
      padding: 10px;
      background: #e0e0e0;
      overflow-x: auto;
    }
    .wave-title {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      margin-bottom: 6px;
      word-break: break-word;
      font-weight: bold;
    }
    .wave-element {
      width: 100%;
      min-height: 100px;
      height: 100px;
      background: #000;
    }
    .wave-button {
      margin-top: 6px;
      font-family: 'Courier New', monospace;
      padding: 4px 8px;
      background: #c0c0c0;
      border: 2px outset #c0c0c0;
      cursor: pointer;
    }
    .wave-button:active {
      border-style: inset;
    }
    .render-error {
      color: red;
      font-size: 13px;
      padding: 10px;
      background: #ffe6e6;
      border: 1px solid #ff9999;
    }
    .taskbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #c0c0c0;
      height: 36px;
      border-top: 2px solid #ffffff;
      display: flex;
      align-items: center;
      padding: 0 8px;
      z-index: 90;
    }
    .start-button {
      padding: 4px 8px;
      background: #c0c0c0;
      border: 2px outset #c0c0c0;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .start-button:active {
      border-style: inset;
    }
    .status-bar {
      margin-left: auto;
      padding: 0 8px;
      font-size: 14px;
    }
    .window-controls {
      display: flex;
    }
    .info-panel {
      background: #fff;
      border: 2px inset #808080;
      padding: 10px;
      margin-top: 10px;
      font-size: 13px;
      max-height: 150px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="desktop-icon" style="top: 20px; left: 30px;" onclick="document.querySelector('.window').style.display = 'block'">
    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIj48cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9IiMwMDAwODAiLz48cGF0aCBkPSJNMTAgMTB2MTJoMTJWMTAuMDFIMTB6bTIgMmg4LjAxdjguMDFIMTJWMTJ6IiBmaWxsPSIjZmZmIi8+PC9zdmc+" width="48" height="48">
    <div>KO II Tool</div>
  </div>
  
  <div class="window">
    <div class="title-bar">
      <span>KO II SpeedUpperCut v0.0.16</span>
      <div class="window-controls">
        <button class="minimize" title="Minimize">_</button>
        <button class="close" title="Close">×</button>
      </div>
    </div>
    <div class="content">
      <div style="display: flex; gap: 8px; margin-bottom: 10px;">
        <div class="win95-inset" style="flex: 1;">
          <label>FIDELITY</label><br>
          <div class="win95-list" data-group="fidelity">
            <div data-value="cd" class="list-item selected">CD (16-bit, 44.1kHz)</div>
            <div data-value="sp8" class="list-item">SP-1200 (8-bit, 22kHz)</div>
            <div data-value="sp16" class="list-item">SP-1200 (16-bit, 22kHz)</div>
            <div data-value="sk" class="list-item">SK-1 (8-bit, 9kHz)</div>
          </div>
        </div>
        <div class="win95-inset" style="flex: 1;">
          <label>CHANNELS</label><br>
          <div class="win95-list" data-group="channels">
            <div data-value="stereo" class="list-item selected">Stereo</div>
            <div data-value="mono" class="list-item">Mono</div>
          </div>
        </div>
      </div>

      <div class="settings">
        <label>EP-133 KO II SETTINGS</label>
        <div class="slider-wrapper">
          <label>Pitch:</label>
          <input type="range" class="slider" id="pitch-slider" min="0" max="127" value="64">
          <span class="slider-value" id="pitch-value">64</span>
        </div>
        <div class="slider-wrapper">
          <label>Release:</label>
          <input type="range" class="slider" id="release-slider" min="0" max="255" value="128">
          <span class="slider-value" id="release-value">128</span>
        </div>
      </div>
      
      <div class="drop-zone" id="drop-zone">
        <i class="fas fa-cloud-upload-alt" style="font-size: 36px;"></i>
        <input type="file" id="audio-upload" accept=".mp3,.wav,.ogg,audio/*" multiple />
        <span>DRAG AND DROP OR SELECT AUDIO FILES</span>
      </div>
      
      <div id="waveform-list" style="margin-top: 10px;"></div>
      <button id="select-file-button">Select Audio Files</button>
      
      <div class="info-panel" id="file-info">
        <div>Drop or select audio files to process</div>
        <div>Files will be sped up 2x to save space</div>
      </div>
    </div>
  </div>

  <div id="overlay">
    <div id="win95-loader">
      <div>Processing Audio Files...</div>
      <div class="progress-bar-container" id="segment-container"></div>
    </div>
  </div>

  <div class="taskbar">
    <div class="start-button">
      <i class="fas fa-bars"></i> Start
    </div>
    <div class="status-bar" id="status-bar">Ready</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/wavesurfer.js@7"></script>

  <script>

    // Возвращает значение pitch из слайдера (например, C3 = 48)
function getPitchValue() {
  const pitch = parseInt(document.getElementById('pitch-slider').value, 10);
  return pitch; // MIDI note (e.g., 36 = C2)
}

// Возвращает значение release из слайдера (0.0 - 1.0)
function getReleaseValue() {
  const release = parseFloat(document.getElementById('release-slider').value);
  return release;
}
// Возвращает параметры fidelity по выбору пользователя
function getFidelitySettings(fidelity) {
  switch (fidelity) {
    case "sp1200-8bit": return { sampleRate: 22050, bitDepth: 8 };
    case "sp1200-16bit": return { sampleRate: 22050, bitDepth: 16 };
    case "sk1": return { sampleRate: 9000, bitDepth: 8 };
    default: return { sampleRate: 44100, bitDepth: 16 }; // CD
  }
}

// Конвертация каналов (стерео <-> моно)
async function convertChannels(buffer, targetChannels) {
  if (buffer.numberOfChannels === targetChannels) return buffer;

  const ctx = new OfflineAudioContext({
    numberOfChannels: targetChannels,
    length: buffer.length,
    sampleRate: buffer.sampleRate,
  });

  const src = ctx.createBufferSource();
  const tmp = ctx.createBuffer(targetChannels, buffer.length, buffer.sampleRate);

  for (let ch = 0; ch < targetChannels; ch++) {
    const input = buffer.getChannelData(Math.min(ch, buffer.numberOfChannels - 1));
    tmp.copyToChannel(input, ch);
  }

  src.buffer = tmp;
  src.connect(ctx.destination);
  src.start();
  return await ctx.startRendering();
}

// Применение скорости и ресемплинга
async function applySpeedAndFidelity(buffer, speedFactor, sampleRate) {
  const length = Math.floor(buffer.length / speedFactor);
  const ctx = new OfflineAudioContext({
    numberOfChannels: buffer.numberOfChannels,
    length,
    sampleRate
  });

  const src = ctx.createBufferSource();
  src.buffer = buffer;
  src.playbackRate.value = speedFactor;
  src.connect(ctx.destination);
  src.start();
  return await ctx.startRendering();
}

// Обработка аудио с учетом всех параметров
async function processAudio(buffer, fidelity, channels) {
  const { sampleRate, bitDepth } = getFidelitySettings(fidelity);
  const channelCount = (channels === "mono") ? 1 : 2;
  const converted = await convertChannels(buffer, channelCount);
  return await applySpeedAndFidelity(converted, 2.0, sampleRate);
}
// Re-encode AudioBuffer to WAV with given settings (sample rate, bit depth, channels)
async function encodeToWavBuffer(audioBuffer, sampleRate, bitDepth, channels) {
  const duration = audioBuffer.duration;
  const offlineCtx = new OfflineAudioContext({
    numberOfChannels: channels,
    length: sampleRate * duration,
    sampleRate
  });

  const bufferSource = offlineCtx.createBufferSource();
  let sourceBuffer = audioBuffer;

  // If channel count doesn't match, convert
  if (audioBuffer.numberOfChannels !== channels) {
    const tmp = offlineCtx.createBuffer(channels, audioBuffer.length, audioBuffer.sampleRate);
    for (let ch = 0; ch < channels; ch++) {
      const input = audioBuffer.getChannelData(Math.min(ch, audioBuffer.numberOfChannels - 1));
      tmp.copyToChannel(input, ch);
    }
    sourceBuffer = tmp;
  }

  bufferSource.buffer = sourceBuffer;
  bufferSource.connect(offlineCtx.destination);
  bufferSource.start();
  const renderedBuffer = await offlineCtx.startRendering();

  // Convert to WAV
  return audioBufferToWav(renderedBuffer, { float32: false, bitDepth });
}
// 👇 Patch: Apply fidelity + channel conversion before exporting
function applyAudioSettings(audioBuffer, fidelity, isMono) {
  let sampleRate = 44100;
  let bitDepth = 16;
  if (fidelity === "sp1200-8bit") {
    sampleRate = 22050;
    bitDepth = 8;
  } else if (fidelity === "sp1200-16bit") {
    sampleRate = 22050;
    bitDepth = 16;
  } else if (fidelity === "sk1") {
    sampleRate = 9000;
    bitDepth = 8;
  }

  const channels = isMono ? 1 : 2;
  return {
    sampleRate,
    bitDepth,
    channels
  };
}

// И применим внутри экспортирующей функции (замените старые значения на эту структуру при экспорте)
function getSampleRate(fidelity) {
      switch (fidelity) {
        case 'SP-1200 (8-bit, 22kHz)': return 22050;
        case 'SP-1200 (16-bit, 22kHz)': return 22050;
        case 'SK-1 (8-bit, 9kHz)': return 9000;
        default: return 44100;
      }
    }

    function getBitDepth(fidelity) {
      switch (fidelity) {
        case 'SP-1200 (8-bit, 22kHz)': return 8;
        case 'SK-1 (8-bit, 9kHz)': return 8;
        default: return 16;
      }
    }

    // Глобальные переменные
    const waveformQueue = [];
    let waveformBusy = false;
    let activeAudioContext = null;
    let createdObjectURLs = [];
    let dragCounter = 0;

    // Инициализация приложения
    document.addEventListener('DOMContentLoaded', async () => {
      initApp();
    });

    function initApp() {
      // Обновление слайдеров
      updateSliderValue('pitch');
      updateSliderValue('release');
      
      // Назначение обработчиков событий
      document.getElementById('pitch-slider').addEventListener('input', () => updateSliderValue('pitch'));
      document.getElementById('release-slider').addEventListener('input', () => updateSliderValue('release'));

      // Обработка списков
      document.querySelectorAll('.win95-list').forEach(group => {
        group.addEventListener('click', e => {
          if (e.target.classList.contains('list-item')) {
            group.querySelectorAll('.list-item').forEach(item => {
              item.classList.remove('selected');
            });
            e.target.classList.add('selected');
            updateStatus(`Fidelity set to: ${e.target.textContent}`);
          }
        });
      });

      // Элементы интерфейса
      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('audio-upload');
      const selectButton = document.getElementById('select-file-button');

      // Drag and drop
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleDrop);
      selectButton.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', handleFileSelect);
      
      // Обработка кнопок окна
      document.querySelector('.title-bar .minimize').addEventListener('click', () => {
        document.querySelector('.window').style.display = 'none';
      });
      
      document.querySelector('.title-bar .close').addEventListener('click', () => {
        document.querySelector('.window').style.display = 'none';
      });
      
      // Стартовый статус
      updateStatus("Ready to process files");
    }

    // Функции обновления интерфейса
    function updateSliderValue(type) {
      const slider = document.getElementById(`${type}-slider`);
      const valueSpan = document.getElementById(`${type}-value`);
      if (slider && valueSpan) {
        valueSpan.textContent = slider.value;
        updateStatus(`${type.charAt(0).toUpperCase() + type.slice(1)} set to: ${slider.value}`);
      }
    }
    
    function updateStatus(message) {
      document.getElementById('status-bar').textContent = message;
    }

    // Drag and drop обработчики
    function handleDragOver(e) {
      e.preventDefault();
      dragCounter++;
      document.getElementById('drop-zone').classList.add('dragover');
    }

    function handleDragLeave() {
      dragCounter--;
      if (dragCounter <= 0) {
        document.getElementById('drop-zone').classList.remove('dragover');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      dragCounter = 0;
      document.getElementById('drop-zone').classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) {
        processFiles(e.dataTransfer.files);
      }
    }

    function handleFileSelect() {
      if (this.files.length) processFiles(this.files);
    }

    // Обработка файлов
    async function processFiles(files) {
      const overlay = document.getElementById('overlay');
      const loader = document.getElementById('win95-loader');
      const segmentContainer = document.getElementById('segment-container');
      const fileInfo = document.getElementById('file-info');

      // Подготовка интерфейса
      overlay.style.display = 'block';
      loader.style.display = 'block';
      fileInfo.innerHTML = '<div>Processing started...</div>';
      segmentContainer.innerHTML = '';
      document.getElementById('waveform-list').innerHTML = '';
      
      updateStatus(`Processing ${files.length} file(s)`);

      // Создание контекста
      activeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Подготовка ZIP
      const zip = new JSZip();
      let stereoOriginal = 0;
      let monoOriginal = 0;
      let totalOriginalSize = 0;
      let totalProcessedSize = 0;
      let processedFiles = 0;

      // Прогресс бар
      const totalSegments = 50;
      for (let i = 0; i < totalSegments; i++) {
        const seg = document.createElement('div');
        seg.className = 'progress-segment';
        segmentContainer.appendChild(seg);
      }

      // Обработка каждого файла
      for (let i = 0; i < files.length; i++) {
        try {
          const file = files[i];
          totalOriginalSize += file.size;
          
          // Обновление информации
          fileInfo.innerHTML += `<div>Processing: ${file.name}</div>`;
          updateStatus(`Processing: ${file.name} (${i+1}/${files.length})`);
          
          // Декодирование аудио
          const arrayBuffer = await file.arrayBuffer();
          const decoded = await activeAudioContext.decodeAudioData(arrayBuffer);
          
          // Статистика каналов
          if (decoded.numberOfChannels === 1) monoOriginal++;
          else if (decoded.numberOfChannels === 2) stereoOriginal++;
          
          // Получение настроек
          const fidelity = getSelectedValue('fidelity');
          const channels = getSelectedValue('channels');
          
          // Обработка аудио - ускорение 2x
          const processed = await processAudio(decoded, fidelity, channels);
          
          // Генерация WAV
          const wavBlob = audioBufferToWav(processed);
          totalProcessedSize += wavBlob.size;
          processedFiles++;
          
          // Добавление в ZIP
          const fileName = file.name.replace(/\.[^/.]+$/, '') + '_ko2.wav';
          zip.file(fileName, wavBlob);
          
          // Визуализация
          enqueueWaveformRender(processed, fileName);
          
          // Обновление информации
          const compressionRatio = (file.size / wavBlob.size).toFixed(2);
          fileInfo.innerHTML += `<div>Processed: ${file.name} (${(wavBlob.size/1024).toFixed(1)}KB, ${compressionRatio}x)</div>`;
          
          // Анимация прогресса
          await animateProgress(i / files.length);
          
        } catch (error) {
          console.error('Error processing file:', error);
          fileInfo.innerHTML += `<div style="color:red">Error: ${error.message}</div>`;
          updateStatus(`Error processing file: ${error.message}`);
        }
      }

      // Завершение прогресс бара
      segmentContainer.querySelectorAll('.progress-segment').forEach(seg => {
        seg.classList.add('active');
      });

      // Скачивание ZIP
      try {
        if (processedFiles > 0) {
          const zipBlob = await zip.generateAsync({ type: "blob" });
          const zipUrl = URL.createObjectURL(zipBlob);
          createdObjectURLs.push(zipUrl);
          
          const a = document.createElement('a');
          a.href = zipUrl;
          a.download = "ko2_processed_audio.zip";
          a.click();
          
          // Статистика
          const fidelity = getSelectedValue('fidelity');
          const channels = getSelectedValue('channels');
          const pitch = document.getElementById('pitch-slider').value;
          const release = document.getElementById('release-slider').value;
          
          fileInfo.innerHTML += `
            <div><b>Processed ${processedFiles} files</b></div>
            <div>Original size: ${(totalOriginalSize / 1024 / 1024).toFixed(2)} MB</div>
            <div>Processed size: ${(totalProcessedSize / 1024 / 1024).toFixed(2)} MB</div>
            <div>Space saved: ${(100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1)}%</div>
            <div>Fidelity: ${fidelity.toUpperCase()}</div>
            <div>Channels: ${channels}</div>
            <div>Pitch: ${pitch}, Release: ${release}</div>
            <div>Stereo: ${stereoOriginal}, Mono: ${monoOriginal}</div>
          `;
          
          updateStatus(`Processed ${processedFiles} files. Space saved: ${(100 - (totalProcessedSize / totalOriginalSize * 100)).toFixed(1)}%`);
        }
      } catch (error) {
        console.error('ZIP creation failed:', error);
        fileInfo.innerHTML += `<div style="color:red">ZIP creation failed: ${error.message}</div>`;
        updateStatus(`ZIP creation failed: ${error.message}`);
      }

      // Закрытие оверлея после рендеринга
      waitForRenderCompletion().then(() => {
        overlay.style.display = 'none';
        loader.style.display = 'none';
        if (activeAudioContext) {
          activeAudioContext.close();
          activeAudioContext = null;
        }
      });
    }

    // Аудио обработка
    function getSelectedValue(name) {
      const group = document.querySelector(`.win95-list[data-group="${name}"]`);
      return group?.querySelector('.list-item.selected')?.dataset.value || 'cd';
    }

    function getFidelitySettings(fidelity) {
      switch (fidelity) {
        case 'sp8': return { sampleRate: 22050, bitDepth: 8 };
        case 'sp16': return { sampleRate: 22050, bitDepth: 16 };
        case 'sk': return { sampleRate: 9000, bitDepth: 8 };
        default: return { sampleRate: 44100, bitDepth: 16 };
      }
    }

    async function processAudio(buffer, fidelity, channels) {
      
      const pitch = 24;
      const release = 1.0;
      const playmode = "one-shot";

      const filenameBase = file.name.replace(/\.[^/.]+$/, "") + "_ko2" + exportExtension;

      const metadata = {
        filename: filenameBase,
        pitch,
        release,
        playmode
      };

      const jsonBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: "application/json" });
      zip.file(filenameBase.replace(exportExtension, ".json"), jsonBlob);
    
      const fidelitySettings = getFidelitySettings(fidelity);
      
      // Ускоряем в 2 раза
      const speedFactor = 2.0;
      
      // Применяем каналы
      const converted = await convertChannels(buffer, channels);
      
      // Применяем фиделити (битрейт и битдеп)
      const downsampleRate = fidelitySettings.sampleRate;
      const processed = await applySpeedAndFidelity(converted, speedFactor, downsampleRate);
      
      return processed;
    }

    async function convertChannels(buffer, channels) {
      if (channels === 'mono' && buffer.numberOfChannels > 1) {
        const ctx = new OfflineAudioContext(
          1, 
          buffer.length, 
          buffer.sampleRate
        );
        
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        
        const merger = ctx.createChannelMerger(1);
        const splitter = ctx.createChannelSplitter(buffer.numberOfChannels);
        source.connect(splitter);
        
        for (let i = 0; i < buffer.numberOfChannels; i++) {
          splitter.connect(merger, i, 0);
        }
        
        merger.connect(ctx.destination);
        source.start();
        return await ctx.startRendering();
      }
      return buffer;
    }

    async function applySpeedAndFidelity(buffer, speed, sampleRate) {
      const duration = buffer.duration / speed;
      const ctx = new OfflineAudioContext(
        buffer.numberOfChannels,
        Math.ceil(duration * sampleRate),
        sampleRate
      );
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.playbackRate.value = speed;
      source.connect(ctx.destination);
      source.start();
      return await ctx.startRendering();
    }

    function audioBufferToWav(buffer) {
      const pitch = parseInt(document.getElementById('pitch-slider')?.value || '64');
      const release = parseInt(document.getElementById('release-slider')?.value || '128');
      const ko2Chunk = writeKO2Chunk(pitch, release);
    
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const length = buffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      
      // Создание WAV-заголовка
      const header = new ArrayBuffer(44);
      const view = new DataView(header);
      
      // RIFF identifier
      writeString(view, 0, 'RIFF');
      // RIFF chunk length
      view.setUint32(4, 36 + length * blockAlign, true);
      // RIFF type
      writeString(view, 8, 'WAVE');
      // Format chunk identifier
      writeString(view, 12, 'fmt ');
      // Format chunk length
      view.setUint32(16, 16, true);
      // Sample format (raw)
      view.setUint16(20, 1, true);
      // Channel count
      view.setUint16(22, numChannels, true);
      // Sample rate
      view.setUint32(24, sampleRate, true);
      // Byte rate (sample rate * block align)
      view.setUint32(28, sampleRate * blockAlign, true);
      // Block align (channel count * bytes per sample)
      view.setUint16(32, blockAlign, true);
      // Bits per sample
      view.setUint16(34, 16, true);
      // Data chunk identifier
      writeString(view, 36, 'data');
      // Data chunk length
      view.setUint32(40, length * blockAlign, true);
      
      // Сборка аудиоданных
      const data = new Uint16Array(length * numChannels);
      let offset = 0;
      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
          data[offset] = sample < 0 ? sample * 32768 : sample * 32767;
          offset++;
        }
      }
      
      return new Blob([header, data.buffer, ko2Chunk], { type: 'audio/wav' });
    }

    
    function writeKO2Chunk(pitch, release) {
      const buffer = new ArrayBuffer(12); // 4 byte ID + 4 byte length + 4 byte data
      const view = new DataView(buffer);
      writeString(view, 0, 'ko2 ');
      view.setUint32(4, 4, true); // chunk size = 4 bytes
      view.setUint8(8, pitch); // 1 byte pitch
      view.setUint16(9, release, true); // 2 bytes release
      view.setUint8(11, 1); // 1 byte playmode (1 = one-shot)
      return buffer;
    }

function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    }

    // Визуализация волны
    function renderWaveform(audioBuffer, filename) {
      return new Promise((resolve) => {
        // Создание контейнера
        const container = document.createElement('div');
        container.className = 'wave-container';
        
        // Заголовок
        const title = document.createElement('div');
        title.className = 'wave-title';
        try {
          title.textContent = decodeURIComponent(filename);
        } catch {
          title.textContent = filename;
        }
        
        // Контейнер волны
        const wave = document.createElement('div');
        wave.className = 'wave-element';
        
        // Кнопка воспроизведения
        const button = document.createElement('button');
        button.className = 'wave-button';
        button.innerHTML = '<i class="fas fa-play"></i> Play Processed Audio';
        
        // Добавление элементов
        container.appendChild(title);
        container.appendChild(wave);
        container.appendChild(button);
        document.getElementById('waveform-list').appendChild(container);
        
        try {
          // Инициализация Wavesurfer
          const wavesurfer = WaveSurfer.create({
            container: wave,
            waveColor: '#0f0',
            progressColor: '#ff0',
            height: 100,
            barWidth: 2,
            minPxPerSec: 100,
            cursorColor: '#f00',
            sampleRate: audioBuffer.sampleRate
          });

          // Обработка готовности
          wavesurfer.on('ready', () => {
            button.addEventListener('click', () => {
              if (wavesurfer.isPlaying()) {
                wavesurfer.pause();
                button.innerHTML = '<i class="fas fa-play"></i> Play Processed Audio';
                updateStatus("Playback paused");
              } else {
                wavesurfer.play();
                button.innerHTML = '<i class="fas fa-pause"></i> Pause';
                updateStatus("Playing processed audio");
              }
            });
            resolve();
          });

          // Обработка ошибок
          wavesurfer.on('error', (err) => {
            console.error('Wavesurfer error:', err);
            wave.innerHTML = '<div class="render-error">Render failed: ' + err.message + '</div>';
            resolve();
          });

          // Загрузка обработанного буфера
          
    const wavBlob = audioBufferToWav(audioBuffer);
    wavesurfer.loadBlob(wavBlob);
    
        } catch (err) {
          console.error('Wavesurfer init error:', err);
          wave.innerHTML = '<div class="render-error">Init failed: ' + err.message + '</div>';
          resolve();
        }
      });
    }

    // Управление очередью рендеринга
    function enqueueWaveformRender(audioBuffer, filename) {
      waveformQueue.push({ audioBuffer, filename });
      if (!waveformBusy) {
        processNextWaveform();
      }
    }

    async function processNextWaveform() {
      if (waveformQueue.length === 0) {
        waveformBusy = false;
        return;
      }

      waveformBusy = true;
      const { audioBuffer, filename } = waveformQueue.shift();
      
      try {
        await renderWaveform(audioBuffer, filename);
      } catch (err) {
        console.error('Waveform render error:', err);
      }
      
      // Обработка следующего элемента
      setTimeout(processNextWaveform, 0);
    }

    // Вспомогательные функции
    function animateProgress(progress) {
      return new Promise(resolve => {
        const segments = document.querySelectorAll('.progress-segment');
        const segmentsToActivate = Math.floor(progress * segments.length);
        
        segments.forEach((seg, i) => {
          if (i <= segmentsToActivate) {
            setTimeout(() => seg.classList.add('active'), i * 20);
          }
        });
        
        setTimeout(resolve, segments.length * 20);
      });
    }

    function waitForRenderCompletion() {
      return new Promise(resolve => {
        const check = () => {
          if (!waveformBusy && waveformQueue.length === 0) {
            resolve();
          } else {
            setTimeout(check, 100);
          }
        };
        check();
      });
    }

    // Очистка при закрытии
    window.addEventListener('beforeunload', () => {
      createdObjectURLs.forEach(url => URL.revokeObjectURL(url));
      if (activeAudioContext) {
        activeAudioContext.close();
      }
    });

// Simple drag and drop as in repitch
const dropzone = document.getElementById('dropzone');
if (dropzone) {
  dropzone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropzone.classList.add('dragover');
  });

  dropzone.addEventListener('dragleave', () => {
    dropzone.classList.remove('dragover');
  });

  dropzone.addEventListener('drop', async (e) => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
      handleFiles(files);
    }
  });
}








  </script>
</body>
</html>